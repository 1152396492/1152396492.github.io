{"meta":{"title":"Amentiraz blog","subtitle":"Never knows best","description":"","author":"Amentiraz","url":"http://1152396492.github.io","root":"/"},"pages":[{"title":"links","date":"2021-09-12T21:14:40.000Z","updated":"2021-12-27T02:58:10.433Z","comments":true,"path":"PY.html","permalink":"http://1152396492.github.io/PY.html","excerpt":"","text":""},{"title":"文件归档","date":"2021-12-27T02:57:15.709Z","updated":"2021-12-27T02:57:15.709Z","comments":true,"path":"archive.html","permalink":"http://1152396492.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"你想活出怎样的人生","slug":"你想活出怎样的人生","date":"2024-04-07T16:03:17.000Z","updated":"2024-04-20T12:32:20.405Z","comments":true,"path":"2024/04/08/你想活出怎样的人生/","link":"","permalink":"http://1152396492.github.io/2024/04/08/%E4%BD%A0%E6%83%B3%E6%B4%BB%E5%87%BA%E6%80%8E%E6%A0%B7%E7%9A%84%E4%BA%BA%E7%94%9F/","excerpt":"大概率是宫崎骏的最后一部作品了，看完感触良多，特此记录。","text":"大概率是宫崎骏的最后一部作品了，看完感触良多，特此记录。 宫崎骏一直是我喜欢不来的动画监督。上大学以前，我只看过他的《幽灵公主》，上大学后先后看了《天空之城》，《红猪》，《千与千寻》，《龙猫》，但是其中除了红猪我还算喜欢，剩下几部实在令我无感。我能很好的欣赏他那天马行空的作画，那种平淡之中若隐若现的思想，那种适合儿童的天真的气氛，但每次点开他的作品都有一种不会失望，但不会期待的情绪。让我来概况他的作品，那就是不计成本的作画，和局部极佳的演出表现，可作为电影，他的叙事情节过于平淡简单，不能很好的激起我个人的共鸣，在《天空之城》他那回归田园的观点更是让我敬而远之。 想到《你想活出怎样的人生》（以下简称《人生》）大概率是他最后一部作品我还是决定去看了。中国上映较晚，于是能在观影前看到很多风声：难以理解，意识流，甚至还有认为这部作品思想是反战败。我很喜欢意识主义动画，在动画领域，我认为意识主义动画才是日本最绚丽的瑰宝。意识主义动画往往以一种含蓄的方式去表达自己的观点，方式就是跳脱常规的剧情讲述，不明所以但似乎蕴含思想的作画，以极大的信息量冲击观众的感官，不追求你能看懂，只是导演团队的自嗨罢了。所以在面对这种动画时，我采用的态度往往是感受这个气氛，顺着导演的情绪去走，若是能窥见他思想的一角那更是极好，但如果在观影中自己获得了某种情绪，那便是更加。例如《EVA》中看完后对于故事为什么这样发展是模糊的，但我能感受到真嗣的在爱中寻找存在的冲动，再例如《FLCL》中，在富有激情的作画中感受到男主的青春与成长（这部片也是在我人生低谷中激励我的一部），《和平保卫战》中看到最后都不明白剧情的发展，但城市上空充满威胁的飞艇所渲染的绝望低气压的气息令人深思。 受到商业化的冲击，如今已经很少看到这种动画了，上一部还不错的意识流动画我印象里还是21年的《漂流少年》。这并不奇怪，商业化意味着降低作者本人的情感表达，更倾向于迎合市场，扁平的剧情更适合现代人快节奏的情感摄取需求。我很喜欢《人生》的一点便在于它无所谓观众的想法，不计成本的作画存粹的输出宫崎骏自己的人生体会，这只有宫崎骏能做得到。 《人生》注定是一部叫好不叫座的作品，它的观影门槛过高，这部电影浓缩了宫崎骏以往的经历和13部电影后更是如此。但遗憾的是中国夸张的宣传让主流人群对这部电影施加了太多不该有的抨击，让我感到非常可惜。甚至在我的影院有人穿着花哨的cos来观影，可以料到评论区是什么情况了。当然你要说我装婆罗门我也没办法，每个人的观念不同罢了。 回到这部电影，在观影途中意外的是时间过的很快，我并没有感到枯燥乏味，同行的不看动画的同学看完也认为虽然看不懂，但不无聊。可以看出它的演出手法是多么高明了。动画主线剧情其实很好理解，男主人公丧母后父亲与母亲的妹妹再婚，在开始与社会的疏离之中，中间穿越进入一个奇幻的世界经历一系列事后重新拥抱世界。主线与《千与千寻》非常像，很符合我对宫崎骏故事编排的理解（笑），但我认为这部片子真正出彩的地方恰恰在此。 我说过，我不喜欢宫崎骏那简单的故事，但很喜欢他在细节的处理，在《人生》中他是怎么“扬长避短”呢，那就是用大量单独的故事去拼接。这些故事的拼接很有说法，因为宫崎骏想把自己人生的关键节点和拍摄的电影融入进去，而这必定会牺牲故事情节的合理性，那怎么减弱这一点呢？那当然是创造一个虚幻的不合理的世界：后妈为什么会去这个世界，那当然是那块神奇的石头诱使的；为什么有墓地，奇幻世界出现什么都不奇怪；什么是第七号羽毛，那便是任君想象了。有人说这样是不是太取巧糊弄观众了，确实，但这些不重要，因为这些细节并不影响整体的表达，还有这部电影并不照顾观众。 我并不是什么宫崎骏迷，所以关于对以往作品和人生的致敬我不甚了解，那些意象的暗示更是无从下手，但我认为nbht的那期视频说的很好，从电影从业者的角度对这部电影进行了剖析，可以看看。 在电影的最开始，能感受到的是男主对世界的疏离感。后妈强抓着他的手抚摸未出生的婴儿，把他拉下车强迫他向战争归来的士兵鞠躬，被霸凌后为了扩大事情的严重性，和隐式的报复他人抓起石头砸向自己的头，这些充满细节的情感流露正是宫崎骏擅长的，在《千与千寻》中也能看到这一点。但是与《千》不同的是他们所改变的方式。千寻通过长期的劳动，不断在妖怪的社会中谋生最终获得了成长，那么本片的男主呢？我认为是阅读了他母亲留下的那本《你想活出怎样的人生》的小说。我也写日记，在我想描述自己通过读了某本书突然醒悟过来改变自己对人生的态度时我发现难以下笔。因为你无法让读者也跟着读一遍你读过的书，重复书中的思想也显得累赘。那么宫崎骏怎么处理的——他不处理，因为你爱看不看。以至于后来男主突然去救后妈，喊后妈“母亲”等等情节让人感到割裂。所以在我看来，中间的情节并不涉及男主的成长，反倒是一种书中理论的实践，当然也可以理解为在经历了宫崎骏人生中的种种事后最终选择拥抱世界，我认为也解释的通。 故事情节本身是简单的，我一直认为宫崎骏的作品情节总是单调，不能算作跌宕起伏。我看到很多网友也是这样的观点，包括押井守也对宫崎骏的剧情结构持批判的态度。所以当我每次抱着审视的态度去看宫崎骏的作品时总是折戟而归——也可以说转变自己的态度，像小孩一样放空自己去欣赏，这样我认为才是观看宫崎骏作品的态度。相比之下，比如押井守的作品，我得高度集中注意力，还得拖拽进度条反复评鉴才能说自己看懂了，虽然这样有点破坏观影体验，我更喜欢后者的严谨。所以如果这个故事单单如此我也不会写这么多了。更令我惊讶的是我能看到宫崎骏思想的变化。 前面说过，我对于天空之城那种回归田园的思想敬而远之，作为左翼的宫崎骏这样想再正常不过了，如果《人生》延续《天空之城》的思想会是怎样呢？恐怕在最后，男主会拿着纯白的积木就开始重塑世界了吧。回归现实没有解决方法，战争无法解决。日本从黄金时代之后一直笼罩在美国的威胁之下，（顺带一提，为什么日本总是在战争类作品中渲染自己的不幸，因为对于泡沫崩溃的一代人来说，他们不仅没有享受到战争的红利，反而面临高压的社会），直到现在日本首相在美国的演讲极力的渲染中国的威胁，想以此获取某些权利。特别是现在中日右翼盛行，似乎回归现实便只有战争，在《进击的巨人》中谏山创认为这是没有办法的，战争会不断的蔓延，非常消极，所以我不喜欢进击的巨人的结局。那么《人生》就解决这个问题了吗？它也没有，它也不能有。一旦它试图解决这个问题，那么就会演变为上世纪前辈的说教，这也是为什么象征宫崎骏的真人拒绝重塑世界。那么它是怎么说的呢，首先象征军国主义和幻想的塔倒了，那些穷凶极恶的鹈鹕重新变得憨态可掬，这也印证了毛的一句话：“中国人民与日本人民是一致的,只有一个敌人,就是日本帝国主义与中国民族败类”。其次，积极的面对现实：真人的母亲回到了自己的时代，即使这样自己会死亡；真人回到了自己的时代，背负着战争的记忆勇敢面对生活。孕育下一代的后妈也回到了自己的时代，不再躲在安全的塔中。当然《人生》没有解决现实中的任何问题，但是它给予观众了一种精神。 这种精神像《EVA》，像《sonny boy》，像《FLCL》：我们毁灭了一切，而这一切已成飘渺。我们很难说我们从中得到了什么，相比得到，我们失去的更多。我们一跃活出了自己想要的人生吗？现实恰恰相反。那么我们该怎么办？像这些不讲人话的意识流作品一样，我们拒绝沉浮，拒绝逃避，在搅成一团的思绪中，在与他人疏远但坚持己见的个性中，活出自己想要的人生,活出这个世界想要的答案。这也是为什么我如此喜欢意识主义动画，如此喜欢这部作品。","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"书评","slug":"书评","permalink":"http://1152396492.github.io/tags/%E4%B9%A6%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"博客使用的图片","slug":"博客使用的图片","date":"2023-11-14T09:58:38.000Z","updated":"2023-11-14T02:07:16.993Z","comments":true,"path":"2023/11/14/博客使用的图片/","link":"","permalink":"http://1152396492.github.io/2023/11/14/%E5%8D%9A%E5%AE%A2%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87/","excerpt":"这里把所有我在博客中使用的图片和相应的地址给放出来，以便后面写文章使用","text":"这里把所有我在博客中使用的图片和相应的地址给放出来，以便后面写文章使用 生活类https://i.postimg.cc/zfxwqzC7/wallhaven-pkw6y3.jpg学习笔记类https://i.postimg.cc/XvqGcw5K/wallhaven-e7pwdw.jpg数学建模类https://i.postimg.cc/CKR5fwym/wallhaven-r2g7rm.jpg算法类https://i.postimg.cc/Dy5wjSnx/46985381-p0-master1200.jpg","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/tags/%E6%9D%82/"}]},{"title":"重新使用博客","slug":"重新使用博客","date":"2023-11-11T11:04:36.000Z","updated":"2023-11-14T01:56:43.886Z","comments":true,"path":"2023/11/11/重新使用博客/","link":"","permalink":"http://1152396492.github.io/2023/11/11/%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%8D%9A%E5%AE%A2/","excerpt":"对许久不使用这个个人博客的解释和对以后本博客的内容的畅想","text":"对许久不使用这个个人博客的解释和对以后本博客的内容的畅想 过去一年都干了啥","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/tags/%E6%9D%82/"}]},{"title":"文件学习笔记","slug":"文件学习笔记","date":"2021-12-28T09:46:28.000Z","updated":"2023-11-14T01:54:37.103Z","comments":true,"path":"2021/12/28/文件学习笔记/","link":"","permalink":"http://1152396492.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"文件是什么文件是指一组相关数据的有序集合，这个数据集有一个名称叫做文件名。文件可以是自己编制的，也可以是系统已有的。事实上我们已经多次使用了文件，例如源程序文件，目标文件、可执行文件、库文件等。为了将结果保存起来，就需要使用文件。将数据以文件的形式存放在光盘、磁盘等外存储器上，可以达到重复利用、永久保存数据的目的。文件可分为普通文件和设备文件两种。通常吧显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的printf、putchar函数就是这类输出。键盘通常被指定标准的输入文件，从键盘上输入意味着以标准输入文件输入数据。scanf、getchar函数就属于这类输入。 文件类型文件可分为ASCII码文件和二进制文件两种。ASCII文件也成为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如数6843的存储形式为：ASCII码：00110110 00111000 00110100 00110011十进制码： 6 8 4 3共占用四个字节。ASCII码文件可在屏幕上按字符显示，例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。二进制文件是按二进制编码的方式来存放文件的。例如，数6843的存储形式为：00011010 10111011只占两个字节。二进制文件也可以在屏幕中显示，但内容无法读懂。输入输出字符流的开始和结束只由程序控制而不受物理符号（如回车符）的控制。因此也把这种文件称作流式文件。 文件指针在C语言中用一个指针变量指向一个文件，这个指针被称为文件指针，通过文件指针可以对它所指的文件进行各种操作。存放文件的有关信息被保存在一个结构体变量中，它是由系统定义的，取名为FILE。在编写源程序时不必关心FILE结构的细节。例如： 1FILE * 指针变量标识符 其中FILE必须为大写，该结构中含有文件名、文件状态和文件当前位置等信息。注意：在操作系统中，文件被作为重要的系统资源来看待。因此，当程序需要访问文件时，程序员必须显式地打开某个文件，并在使用后关闭它。程序中所有对文件的操作都通过文件指针来实现。 文件打开操作C语言没有输入输出语句，对文件的读写都是用看库函数来实现的。对文件进行操作时应遵循一下步骤： 打开文件。打开文件是指请求系统为指定文件分配内存缓冲区，建立文件的各种有关信息，文件使用前必须先打开。 读写文件。包括文件的读、写、定位等操作。 关闭文件。确保数据完整写入文件并释放内存缓冲区。 打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件。关闭文件则是断开指针与文件之间的联系，也就是禁止再对该文件操作。fopen函数用来打开一个文件，其调用的一般形式为： 1文件指针名 = fopen ( 文件名 , 使用文件方式 ) ; 文件指针名必须是被说明为FILE类型的指针变量；文件名使被打开文件的文件名，可以是字符串常量或字符串数组；使用文件方式是指文件类型和操作要求。例如： 12FILE * fp ; fp = ( &quot;file a&quot; , &quot;r&quot; ) ; 其意义使在当前目录下打开文件file a，只允许进行读入操作，并使fp指向该文件。又如： 12FILE * fp ; fp = ( &quot;c:\\\\test&quot; , &quot;rb&quot; ) ; 其意义是打开C驱动磁盘的根目录下的文件test，这是一个二进制文件，只允许按二进制的方式进行读操作。两个反斜杠”\\&quot;第一个表示转义字符，第二个表示根目录。或者使用： 1FILE * fopen ( const char * filename , const char * mode ) ; 返回失败时返回空指针NULL使用文件的方式共有12种，下表给出其符号以及意义。文件使用方式|意义:-:|:-:r|打开文件，只读w|打开或建立文件只写a|追加打开一个文本文件，并在文件末尾写数据rb|二进制文件，同上wb|二进制文件，同上ab|二进制文件，同上r+|读+写w+|读+写a+|读+写rb+&amp;wb+&amp;ab+|类推 总结如下：r(ead) , w(rite) , a(ppend) , t(ext) , b(inary) 。+：读和写查看是否成功读入 1234if ( ( fp = fopen ( &quot;text&quot; , &quot;rb&quot; ) ) == NULL ) &#123; cout &lt;&lt; &quot;error&quot; ; getch ( ) ; exit ( 1 ) ; &#125; 文件关闭操作123FILE * fp ; fp = fopen ( &quot;a.out&quot; , &quot;r&quot; ) ; fclose ( fp ) ; 关闭成功返回值为0，否则为非零值如果打开了多个文件且需要统一关闭： 1int fcloseall ( ) ; 此函数关闭除了标准流意外的所有打开流，刷新所有的流缓冲区，并关闭返回的参数，否则返回EOF。标准流：stdin，stdout，stderr 文件结束检测1int feof ( FLIE * fp ) ; 文件未结束返回0，已结束返回真。 文件错误检测函数1int ferror ( FILE * fp ) ; 发生错误返回非零，否则返回0 定位文件位置指针函数1fseek ( FILE * fp , long offset , int startpos ) ; offset表示目标位置相对起始点的偏移量，要求偏移量为long型数据以便在文件长度大于64KB时不会出错，当用常量表示位移量时，要求加后缀L.startpos表示从何处计算偏移量：SEEK_SET:0 , SEEK_CUR:1 , SEEK_END:2 ;fseek函数一般用于二进制文件，在文本文件中由于要进行转换，故往往会出现错误。 重置文件位置指针函数1rewind ( FILE * fp ) ; 移动到文件开始的位置。无返回值 移动指针到当前位置函数1long ftell ( FILE * p ) ; 若函数调用成功则函数的返回值时当前读写位置偏离文件头部的字节数，否则返回-1 ；文件的长度 12ftell ( fp , 0L , SEEK_END ) ;len = ftell ( fp ) ; 面向字符的文件读写操作1fputc ( int c , FILE * stream ) ; c是带写入的字符，可以是字符常量或者变量。每写入一个字符，文件内部位置指针将向后移动一个字节。返回值为字符或者EOF。如果用写或者读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始，如需保留原有文件内容，必须以追加的方式打开文件。 1ch = fgetc ( FILE * stream ) ; 读取的文件必须是以读写或读的方式打开的。 面向字符串的文件读写操作1char * fgets ( char * string , int n , FILE * stream ) ; 函数的功能是从stream指向的文件中逐一读取n-1个字符，并将读取的字符保存到string指向的连续存储空间。在读取n-1个字符之前如果遇到了换行符或EOF，则读取结束。 1int fputs ( const char * string , FILE * stream ) ; 执行成功返回非负整数，否则返回EOF。不会把\\0写入文件。 面向格式化输入输出的文件读写操作1int fscanf ( FILE * stream , const char * format[,argument]...) ; 返回值为读取正确的数据个数， EOF为读取错误或文件结束。 1int fprintf ( FILE * stream , const char * format[,argument]... ) ; 返回值为正确写入返回数据的个数，负值为读写错误。 面向信息块的文件读写操作12fread ( void * buffer , int size , int count , FILE * fp ) ; fwrite ( void * buffer , int size , int count , FILE * fp ) ; 例如：fread ( fa , 4 , 5 , fp ) ; 的意义是从fp所指的文件中，每次读4个字节，送入实数数组fa中，连续读5次。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言","slug":"C语言","permalink":"http://1152396492.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"西电新生赛网络赛题解","slug":"西电新生赛网络赛题解","date":"2021-12-11T10:19:40.000Z","updated":"2023-11-14T01:55:01.875Z","comments":true,"path":"2021/12/11/西电新生赛网络赛题解/","link":"","permalink":"http://1152396492.github.io/2021/12/11/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9B%E7%BD%91%E7%BB%9C%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"持续六天的新生赛终于落下了帷幕，打了8道题，第21名，对于两年没有碰过oi的我来说已经是一个不错的成绩了，如果运气好的话还能水到一等奖，怎么说都血赚。但不得不说的是，我这次的状态比两年前打CSPS要好太多了，如果以我现在的心理素质和之前的知识水平去打，那肯定是不同的结果了。这次比赛原本想用Amentiraz这个昵称去打，但思来想去还是用了最开始的dsfly昵称去打，一来这个名称短（够装B），二来这个名称是我最开始打oi时的昵称，意味着一个新的开始吧。说是六天，实际上就打了前三天，主要是还有本职的学习工作，第二是因为小说太好看了（笑）。还是把除了J题以外的所有题都摸了一遍，可以说除了J题我做不出来，其余的花时间都能做出来，放了H题和K题，H题是因为纯模拟暴力，太恶心了，不想写，K题是让你直接输出时间复杂度，搞了几下没出来，又不想去看资料，于是就放了。（留着时间看番不香吗）","text":"持续六天的新生赛终于落下了帷幕，打了8道题，第21名，对于两年没有碰过oi的我来说已经是一个不错的成绩了，如果运气好的话还能水到一等奖，怎么说都血赚。但不得不说的是，我这次的状态比两年前打CSPS要好太多了，如果以我现在的心理素质和之前的知识水平去打，那肯定是不同的结果了。这次比赛原本想用Amentiraz这个昵称去打，但思来想去还是用了最开始的dsfly昵称去打，一来这个名称短（够装B），二来这个名称是我最开始打oi时的昵称，意味着一个新的开始吧。说是六天，实际上就打了前三天，主要是还有本职的学习工作，第二是因为小说太好看了（笑）。还是把除了J题以外的所有题都摸了一遍，可以说除了J题我做不出来，其余的花时间都能做出来，放了H题和K题，H题是因为纯模拟暴力，太恶心了，不想写，K题是让你直接输出时间复杂度，搞了几下没出来，又不想去看资料，于是就放了。（留着时间看番不香吗） T1位运算题意：输入a，b，输出a&amp;b,a|b,a^b的二进制表示签到题，特判值为0的情况，没啥说的代码： 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std ;void deal ( int x ) &#123; if ( x == 0 ) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl ; return ; &#125; int a[10000] , len = 1 ; while ( x ) &#123; a[len++] = x &amp; 1 ; x &gt;&gt;= 1 ; &#125; for ( int i = len - 1 ; i &gt;= 1 ; i -- ) cout &lt;&lt; a[i] ; cout &lt;&lt; endl ; return ;&#125;int main ( ) &#123; int a , b ; scanf ( &quot;%d%d&quot; , &amp; a , &amp; b ) ; int ans1 = a &amp; b , ans2 = a | b , ans3 = a ^ b ; deal ( ans1 ) ; deal ( ans2 ) ; deal ( ans3 ) ; return 0 ;&#125; T21931题面：歌颂我们伟大的母校90周年的题目。一眼看不出来，先打表枚举找规律。大胆猜想最佳情况是把每一张劵平摊开，尽可能的覆盖到每一次买套餐，小心求证列几个数学公式就出来了，这题不难。关键是你要眼尖的看出如果不买饭那么就不花钱。 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std ;int main ( ) &#123; int T ; scanf ( &quot;%d&quot; , &amp; T ) ; while ( T -- ) &#123; int n , m ; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; int a[1000] , tot = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) , tot += a[i] ; if ( m &gt; n ) &#123; cout &lt;&lt; tot * 2 * ( m - n ) + tot * n - tot &lt;&lt; endl ; &#125; else if ( m == 0 ) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl ; else cout &lt;&lt; m * tot - tot &lt;&lt; endl ; &#125; return 0 ;&#125; T3等级展示题意：类比于qq的等级，对应星星、月亮、太阳、皇冠有*,(,0,W给出等级，输出图标签到题，简单的一批，直接上代码 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n / 64 ; i ++ ) cout &lt;&lt; &quot;W&quot; ; n %= 64 ; for ( int i = 1 ; i &lt;= n / 16 ; i ++ ) cout &lt;&lt; &quot;O&quot; ; n %= 16 ; for ( int i = 1 ; i &lt;= n / 4 ; i ++ ) cout &lt;&lt; &quot;(&quot; ; n %= 4 ; for ( int i = 1 ; i &lt;= n ; i ++ ) cout &lt;&lt; &quot;*&quot; ; return 0 ; &#125; T4边权之和题意：n个点的无向完全图，对于每个点有点权ai，对于两个点i，j的边权为|ai-aj|，统计边权之和对于998244353取模值考虑把绝对值去掉，先把数组给排序，计算它们的和，如何整体计算即可，也不难。至此，新生赛所有的送分题以及送完了，后面的题或多或少都有些难度，这四道题基本上是所有接触过c的人都能写出来的，只是快慢罢了。我新生赛来迟了30min，我写到这道题时排位30多名，后面排名基本上是只升不降，说明大部分人开始卡住了。 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std ; const long long mod = 998244353 ;long long a[1000006] ;bool cmp ( int x , int y ) &#123; return x &gt; y ; &#125; int main ( ) &#123; int n ; long long ans = 0 , tot = 0 ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%lld&quot; , &amp; a[i] ) ; tot += a[i] ; &#125; sort ( a + 1 , a + 1 + n , cmp ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; tot -= a[i] ; ans += ( ( long long ) ( n - i ) ) * a[i] - tot ; ans %= mod ; &#125; cout &lt;&lt; ans ; return 0 ; &#125; T5tsy的轻音梦（没想到在这都能见到轻音厨，但可惜的是这个轻音厨太坑了）题面：请大家先看看那位交了48次都没过的大佬：怎么说呢，从第一天开始我就仰望大佬的英姿，虽然最后大佬跟我A的题是一个数，但就凭这道题我就不得不佩服他。我一度怀疑他在整活，但看到他在比赛终都没有A掉这题，不由得对他产生崇高的敬意。我开始也被绕进去了，很明显，我们可以联想到幻方，幻方似乎是斜着放，中间是最中间的数，然后呈现一定规律依次放入数，但是我们怎么类比推理都无法得出正确的解法，特别是输出-1给我了很大的迷惑，是不是要考虑奇数次项的奇偶关系？是不是对称放？等等，然而这些都是放屁。想出来正解后我觉得自己是个傻逼。正解：对于奇数次项考虑对角线为分隔除了正中间的一定为偶其余的依次按从大到小的顺序从对角线依次填入，保证左边是偶右边是奇就行。对于偶数次项直接依次填入即可（ls的轻音梦碎了）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std ; int a[1005][1005] ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; if ( n % 2 == 0 ) &#123; for ( int i = 1 ; i &lt;= n * n ; i ++ ) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; ; if ( i % n == 0 ) cout &lt;&lt; endl ; &#125; &#125; else if ( n == 1 ) cout &lt;&lt; &quot;1&quot; ; else &#123; for ( int i = 1 ; i &lt;= n / 2 ; i ++ ) &#123; a[i][i] = i * 2 ; a[i][i+1] = i * 2 + 1 ; &#125; a[1][3] = 1 ; a[n/2+1][n/2] = n + 1 ; for ( int i = 1 ; i &lt;= n / 2 + 1 ; i ++ ) &#123; int x = n / 2 + i , y = n / 2 + i ; a[x][y] = n + 1 + i * 2 - 1 ; a[x+1][y] = n + 1 + i * 2 ; &#125; int cur1 = n + 1 + ( n / 2 + 1 ) * 2 + 1 ; int cur2 = cur1 - 1 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; for ( int j = 1 ; j &lt;= n ; j ++ ) &#123; if ( ! a[i][j] ) &#123; if ( i &gt; j ) a[i][j] = cur2 , cur2 += 2 ; if ( j &gt; i ) a[i][j] = cur1 , cur1 += 2 ; &#125; cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; T6奇怪的排序题意：这题是很有意思的一道题，考察算法线段树和逆序对，只能说挺难想的吧，难度估计有提高组D2T1的难度。我们发现这个神奇的算法是把每个最大的数抬到第i个位置上并对前i个数排序，第i+1个数按照大小顺序交换到自己的位置上，交换的次数为这个数不重复的逆序对。本身分析到这里我以为套个逆序对就完了，结果发现是不重复的，然后我就弄了一个小暴力，把这些重复的数强制给删掉，结果时间复杂度为O(n^2*logn)比他原来的还大，emmm。对于常见的求逆序对的方法归并和树状数组我都不是很熟悉，于是我就用最无脑的线段树去做，依次判断这个数是否读入过然后决定是否加入到逆序对的计算，最后加起来就行。时间复杂度为O(nlogn)代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ;typedef long long LL ;const int maxn = 200005 ;struct L &#123; int val , add ;&#125; t[maxn&lt;&lt;2] ;int n , m ; LL sum = 0 ;struct M &#123; int val , id ;&#125; a[maxn] ;int vis[maxn] , arank[maxn] ;bool cmp ( M x , M y ) &#123; if ( x.val == y.val ) return x.id &lt; y.id ; return x.val &lt; y.val ;&#125;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) , t[p&lt;&lt;1|1].add += t[p].add ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , int z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ;&#125;int ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; int ans = 0 ; if ( x &lt;= mid ) ans = ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans = ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ;&#125;int main ( ) &#123; scanf ( &quot;%d&quot; , &amp; n ) ; int maxn = 0 , site = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%d&quot; , &amp; a[i].val ) ; if ( a[i].val &gt; maxn ) maxn = a[i].val , site = i ; &#125; for ( int i = 1 ; i &lt;= site ; i ++ ) &#123; if ( a[i].val &gt; a[1].val ) &#123; swap ( a[i].val , a[1].val ) ; sum += 1LL ; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) a[i].id = i ; sort ( a + 1 , a + 1 + n , cmp ) ; int cur = 2 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; if ( a[i].val == a[i-1].val ) cur -- ; arank[a[i].id] = cur ++ ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; sum += ( LL ) ( ask ( 1 , 1 , n , arank[i] , arank[i] ) ) ; if ( vis[arank[i]] ) continue ; vis[arank[i]] ++ ; change ( 1 , 1 , n , 1 , arank[i] - 1 , 1 ) ; &#125; cout &lt;&lt; sum ; return 0 ;&#125; T7更高更妙的字符游戏题面：对于我来说，博弈论分为两种，一种是简单的，一种是做不出来的。我在比赛中惊喜的发现居然有超过5个人做出来了这道题，我稍加思索，然后大胆假设，也没小心求证，直接交了然后就A了，www。考虑两种必死的情况，也就是之差一个的和不差的，直接判断就行。对于其它情况，我们从上帝视角来看，如果是我发现下一步我可能会输，我们直接把那个字符删了就行，但是万一删了还是必死呢。我们假设有abcabc这种情况，我们肯定不可能删b，删了就死，但我们可以删最边上的a和c啊，那么最终的赢家只由字符串的大小决定 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ; int main ( ) &#123; int T ; scanf ( &quot;%d&quot; , &amp; T ) ; int flag = 2 ; while ( T -- ) &#123; flag = 2 ; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; char a[1000006] ; a[n+1] = 0 ; scanf ( &quot;%s&quot; , a + 1 ) ; for ( int i = 1 ; i &lt;= n - 1 ; i ++ ) &#123; if ( a[i] == a[i+1] ) flag = 0 ; if ( a[i] == a[i+2] &amp;&amp; i + 2 &lt;= n ) flag = min ( flag , 1 ) ; &#125; if ( flag == 0 ) cout &lt;&lt; &quot;pllj&quot; &lt;&lt; endl ; else if ( flag == 1 ) cout &lt;&lt; &quot;freesin&quot; &lt;&lt; endl ; else &#123; flag = n % 2 ; if ( flag == 0 ) cout &lt;&lt; &quot;pllj&quot; &lt;&lt; endl ; else if ( flag == 1 ) cout &lt;&lt; &quot;freesin&quot; &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; T8内存占用计算纯模拟，利用高精的思想去比较，乘法就先判断位数够不够如果正好就逐位比较，想了思路感觉很恶心没写代码，如果说错了还请谅解。 T9tsy的排序题面： 三年oi一场空，不开long long见祖宗 每个数只出现一次，我们可以计算它们的逆序对，然后就可以算出它们的正序对等等数据，所以我们只需枚举中间两位，答案就是对于每个逆序对，求两个数左边比他们小的和右边比它们大的数的积。但这个算法的复杂度还是O(n^2)，我们把每个数从大到小丢入线段树中，把标号大于它本身的数都加上它的正序对的个数，强制强制把时间复杂度压缩到O(nlogn)，再一次性乘起来就行。注意一定要开longlong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std ; typedef long long LL ; const int maxn = 300005 ; const int mod = 35198030 ; struct L &#123; LL add , val ;&#125; t[maxn&lt;&lt;2] ; int a[maxn] ;struct M &#123; int val , id ;&#125; f[maxn] ; LL g[maxn] ;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) % mod , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1].add %= mod ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) % mod , t[p&lt;&lt;1|1].add += t[p].add ; t[p&lt;&lt;1|1].add %= mod ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; t[p].val %= mod , t[p].add %= mod ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) % mod ;&#125;LL ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val % mod ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; LL ans = 0 ; if ( x &lt;= mid ) ans = ( ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ) % mod ; if ( y &gt; mid ) ans = ( ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) % mod ; return ans ; &#125;int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; f[a[i]].val = ask ( 1 , 1 , n , a[i] , a[i] ) ; f[a[i]].id = i ; change ( 1 , 1 , n , a[i] , n , 1 ) ; &#125; for ( int i = 0 ; i &lt;= ( n &lt;&lt; 2 ) ; i ++ ) t[i].add = t[i].val = 0 ; for ( int i = n ; i &gt;= 1 ; i -- ) &#123; int ind = f[i].id ; g[i] = ( ask ( 1 , 1 , n , ind , ind ) ) % mod ; change ( 1 , 1 , n , ind , n , f[i].val ) ; &#125; LL ans = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; LL num = ( ( n - a[i] ) - ( i - f[a[i]].val - 1 ) ) % mod ; ans = ( ans + ( num * g[a[i]] ) ) % mod ; &#125; cout &lt;&lt; ans ; return 0 ; &#125; T10璀璨星空题意：没去做，也没有想，全场也只有六个做出来了，后面如果它们发题解再补吧。（还得补高数欠下的） T11复杂度理论初步题意：提交了几次没对就没提交了。有几个结论还是可以记下来：对于for循环的时间复杂度就是最内层之积，对于递归就是递归的次数*每次递归的时间复杂度。同样的，有题解再做吧。","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"DP","slug":"DP","date":"2021-12-02T17:26:14.000Z","updated":"2023-11-11T03:38:02.341Z","comments":true,"path":"2021/12/03/DP/","link":"","permalink":"http://1152396492.github.io/2021/12/03/DP/","excerpt":"学了三天DP连个P都不会，总的来说就是寄了，每道题不看题解就做不来，试着做了做三道提高组难度的题，做出来了俩，另外一个没有思路。这俩题我都想出了大部分思路，但最后几步由于经验问题没想出来。做完后我以为我懂了，然后膨胀了，去挑战低价购买这道题。然后不出意外寄了。打算先不弄这个了，等以后在弄，先把之前写的贴上来吧。","text":"学了三天DP连个P都不会，总的来说就是寄了，每道题不看题解就做不来，试着做了做三道提高组难度的题，做出来了俩，另外一个没有思路。这俩题我都想出了大部分思路，但最后几步由于经验问题没想出来。做完后我以为我懂了，然后膨胀了，去挑战低价购买这道题。然后不出意外寄了。打算先不弄这个了，等以后在弄，先把之前写的贴上来吧。 珈百璃的堕落这番是好看的，题是不会的。这道题有三个麻烦的点，一个是范围的确定，一个是dp数组的含义确定，还有一个是压缩数组的大小。通过这道题我掌握了基本的DP递推的根据和要领，意思就是我能证明dp递推的正确性了，但然而并没有什么卵用，不会的还是不会。我在高中时就做出来了这道题，但我认为在我高中的时候是不可能想出这道题的思路的，可以说我高中学竞赛就是在自欺欺人了（笑）。但讲道理的是，我起步太慢了，那个时候我也不是什么天才，依葫芦画瓢才是我应该干的，不管怎样我现在是不能这么干了。一个很重要的点是，我们要继承上一个状态，又不能破坏现在的状态，所以起码要二维的数组，我们要尽力压缩空间，注意到第一维只会用到上一个的状态，所以我们调整一下。代码： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std ; int tots , totc , dp[2][2000006] ; int T = 1000000 ; char a[2000006] ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; int l = 0 , r = 0 ; for ( int i = 0 ; i &lt;= 2000006 ; i ++ ) dp[0][i] = dp[1][i] = -100000006 ; dp[0][T] = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%s&quot; , a ) ; int len = strlen ( a ) , tots = 0 , totc = 0 ; for ( int j = 0 ; j &lt; len ; j += 2 ) a[j] == &#x27;s&#x27; ? tots ++ : totc ++ ; int v = totc , w = tots - totc ; l = min ( l + w , l ) ; r = max ( r + w , r ) ; for ( int j = l ; j &lt;= r ; j ++ ) &#123; dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j] , dp[i&amp;1][T+j] ) ; dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j-w] + v , dp[i&amp;1][T+j] ) ; &#125; &#125; cout &lt;&lt; dp[n&amp;1][T] ; return 0 ; &#125; 垃圾陷阱其实高度和维持生命的时间可以换一下，就是时间做数组，生命做值，但太麻烦了，就没写。要时刻记住当前状态由上一个状态推导而来，别自己吓自己。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ; struct L &#123; int t , f , h ; &#125; trash[1005] ; int dp[105][105] ; bool cmp ( L x , L y ) &#123; return x.t &lt; y.t ; &#125; int main ( ) &#123; int D , G ; scanf ( &quot;%d%d&quot; , &amp; D , &amp; G ) ; for ( int i = 1 ; i &lt;= G ; i ++ ) scanf ( &quot;%d%d%d&quot; , &amp; trash[i].t , &amp; trash[i].f , &amp; trash[i].h ) ; sort ( trash + 1 , trash + 1 + G , cmp ) ; dp[0][0] = 10 ; for ( int i = 1 ; i &lt;= G ; i ++ ) &#123; for ( int j = 0 ; j &lt;= D ; j ++ ) &#123; if ( j &gt;= trash[i].h &amp;&amp; dp[i-1][j-trash[i].h] &gt;= trash[i].t ) &#123; dp[i][j] = max ( dp[i-1][j-trash[i].h] ,dp[i][j] ) ; &#125; if ( dp[i-1][j] &gt;= trash[i].t ) &#123; dp[i][j] = max ( dp[i-1][j] + trash[i].f , dp[i][j] ) ; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= G ; i ++ ) &#123; if ( dp[i][D] != 0 ) &#123; cout &lt;&lt; trash[i].t ; return 0 ; &#125; &#125; int now = 10 ; for ( int i = 1 ; i &lt;= G; i ++ ) &#123; if ( now &lt; trash[i].t - trash[i-1].t ) &#123; cout &lt;&lt; trash[i-1].t + now ; return 0 ; &#125; else now = now - trash[i].t + trash[i-1].t + trash[i].f ; &#125; cout &lt;&lt; trash[G].t + now ; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://1152396492.github.io/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Tarjan","slug":"Tarjan","date":"2021-11-29T16:50:27.000Z","updated":"2021-12-25T08:27:16.300Z","comments":true,"path":"2021/11/30/Tarjan/","link":"","permalink":"http://1152396492.github.io/2021/11/30/Tarjan/","excerpt":"想当年高中组织活动的时候我还专门写过Tarjan的流程和证明，如今已经忘的干干净净，原来的代码也找不到了，只能现写了。总的来说就是利用一个栈，将每个访问到的点push入栈，在寻找的过程中记录两个值，一个是dfn——它是第几个搜索到的，一个是low——它能衍生的点中dfn最小的值。如果一个点dfn==low说明它本身就是最小的点，把它及它栈以上的点全部pop出来就行，因为它上面的点必定是与它形成强联通分量。我们不妨假设它上面的点有不是它强联通分量的，那么此点在回溯到它本身的时候只有两种情况，一是它本身是强联通最小的点，那么在找到此点时会把它上面的点全部pop出去，另一种是它不是最小点，那么在遍历的过程中总会到第一种情况把它排除。Tarjan程序是正确无误的，然后最后要跑一个拓扑，然鹅我不大会。luogu上爆了40pt，然后去看别人的题解秒懂。用拓扑可以优化掉ans、Q、new_val等等数组，估计就80pt了，然后我们还得用dp去解决菊花图这种类型的数据。这道题还给人一个教训是，对于缩点的题，我们记录下每条路径的开始与结束去构造新图，没必要单独列个Q这种数组。40pt代码如下：（其实会个Tarjan就行了吧）","text":"想当年高中组织活动的时候我还专门写过Tarjan的流程和证明，如今已经忘的干干净净，原来的代码也找不到了，只能现写了。总的来说就是利用一个栈，将每个访问到的点push入栈，在寻找的过程中记录两个值，一个是dfn——它是第几个搜索到的，一个是low——它能衍生的点中dfn最小的值。如果一个点dfn==low说明它本身就是最小的点，把它及它栈以上的点全部pop出来就行，因为它上面的点必定是与它形成强联通分量。我们不妨假设它上面的点有不是它强联通分量的，那么此点在回溯到它本身的时候只有两种情况，一是它本身是强联通最小的点，那么在找到此点时会把它上面的点全部pop出去，另一种是它不是最小点，那么在遍历的过程中总会到第一种情况把它排除。Tarjan程序是正确无误的，然后最后要跑一个拓扑，然鹅我不大会。luogu上爆了40pt，然后去看别人的题解秒懂。用拓扑可以优化掉ans、Q、new_val等等数组，估计就80pt了，然后我们还得用dp去解决菊花图这种类型的数据。这道题还给人一个教训是，对于缩点的题，我们记录下每条路径的开始与结束去构造新图，没必要单独列个Q这种数组。40pt代码如下：（其实会个Tarjan就行了吧） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std ; const int maxn = 100005 ; int n , m ; int head[maxn] , val[maxn] , nex[maxn] , cnt , to[maxn] , group[10004] ; int tot , ind , a[10004] , stac[10004] , dfn[10004] , vis[10004] , low[10004] ;queue &lt; int &gt; Q[10004] ; int col , in[10004] , new_val[10004] ; int ans[10004] , num ; void add ( int x , int y ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; &#125; void Tarjan ( int u ) &#123; dfn[u] = low[u] = ++ tot ; vis[u] = 1 ; stac[++ind] = u ; for ( int i = head[u] ; i ; i = nex[i] ) &#123; if ( ! dfn[to[i]] ) &#123; Tarjan ( to[i] ) ; low[u] = min ( low[u] , low[to[i]] ) ; &#125; else if ( vis[to[i]] ) &#123; low[u] = min ( low[u] , low[to[i]] ) ; &#125; &#125; if ( low[u] == dfn[u] ) &#123; int v ; col ++ ; while ( v = stac[ind--] ) &#123; Q[col].push ( v ) ; group[v] = col ; vis[v] = 0 ; if ( v == u ) break ; &#125; &#125;&#125;void dfs ( int x , int val ) &#123; int flag = 0 ; for ( int i = head[x] ; i ; i ++ ) &#123; flag = 1 ; dfs ( to[i] , val + new_val[to[i]] ) ; &#125; if ( ! flag ) &#123; ans[++num] = val ; &#125;&#125;void topo ( ) &#123; for ( int i = 1 ; i &lt;= col ; i ++ ) &#123; if ( in[i] == 0 ) &#123; dfs ( i + n , new_val[i] ) ; &#125; &#125;&#125;bool cmp ( int x , int y ) &#123; return x &gt; y ; &#125; int main ( ) &#123; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; while ( m -- ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; add ( x , y ) ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; if ( ! dfn[i] ) Tarjan ( i ) ; &#125; for ( int i = 1 ; i &lt;= col ; i ++ ) &#123; int new_node = i + n , val = 0 ; while ( ! Q[i].empty ( ) ) &#123; int x = Q[i].front ( ) ; Q[i].pop ( ) ; val += a[x] ; for ( int j = head[x] ; j ; j = nex[j] ) &#123; if ( group[to[j]] == group[x] ) continue ; add ( new_node , group[to[j]] + n ) ; in[to[j]] ++ ; &#125; &#125; new_val[i] = val ; &#125; topo ( ) ; sort ( ans + 1 , ans + 1 + num , cmp ) ; printf ( &quot;%d&quot; , ans[1] ) ; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://1152396492.github.io/tags/Tarjan/"}]},{"title":"LCA","slug":"LCA","date":"2021-11-29T11:20:10.000Z","updated":"2021-12-25T08:29:08.943Z","comments":true,"path":"2021/11/29/LCA/","link":"","permalink":"http://1152396492.github.io/2021/11/29/LCA/","excerpt":"LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 对于一棵树来说，我们为了求它的最近公共祖先其实思路和快速幂是差不多的，我们不能直接一个个的向上查找，这样会使时间复杂度爆表，我们应当以2^k的速率往上找，这样可以使其时间复杂度降为log级别。不得不说luogu上的题解实在是晦涩难懂，我能明白他们在寻找相同深度的点的时候使用log可以更快的找到，但是其实可以一层层的向上跳，可能时间复杂度常数上乘个5左右的数，但影响不大。（还是自己的代码好懂）听说树链剖分也可以做，但这玩意写起来太麻烦了，我高中最快时写一遍也要半个小时（毕竟100多行）总之，我们求LCA时首先找每个节点2^i的父亲，然后先将它们跳到相同的深度然后再同时向上跳，注意特判其中一个节点就是LCA。","text":"LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 对于一棵树来说，我们为了求它的最近公共祖先其实思路和快速幂是差不多的，我们不能直接一个个的向上查找，这样会使时间复杂度爆表，我们应当以2^k的速率往上找，这样可以使其时间复杂度降为log级别。不得不说luogu上的题解实在是晦涩难懂，我能明白他们在寻找相同深度的点的时候使用log可以更快的找到，但是其实可以一层层的向上跳，可能时间复杂度常数上乘个5左右的数，但影响不大。（还是自己的代码好懂）听说树链剖分也可以做，但这玩意写起来太麻烦了，我高中最快时写一遍也要半个小时（毕竟100多行）总之，我们求LCA时首先找每个节点2^i的父亲，然后先将它们跳到相同的深度然后再同时向上跳，注意特判其中一个节点就是LCA。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std ;const int maxn = 1000005 ;int n , m , s ;int head[maxn] , to[maxn] , nex[maxn] , cnt = 0 ;int father[maxn][20] , dep[maxn] ;void add ( int x , int y ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; &#125;void dfs ( int x , int fa , int depth ) &#123; father[x][0] = fa ; dep[x] = depth ; for ( int i = 1 ; i &lt;= 19 ; i ++ ) &#123; father[x][i] = father[father[x][i-1]][i-1] ; &#125; for ( int i = head[x] ; i ; i = nex[i] ) &#123; if ( to[i] == fa ) continue ; dfs ( to[i] , x , depth + 1 ) ; &#125;&#125;int LCA ( int x , int y ) &#123; if ( dep[x] &lt; dep[y] ) swap ( x , y ) ; for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123; if ( dep[father[x][i]] &gt;= dep[y] ) &#123; x = father[x][i] ; &#125; &#125; if ( x == y ) return x ; for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123; if ( father[x][i] != father[y][i] ) &#123; x = father[x][i] , y = father[y][i] ; &#125; &#125; return father[x][0] ;&#125;int main ( ) &#123; scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ; for ( int i = 1 ; i &lt; n ; i ++ ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; add ( x , y ) ; add ( y , x ) ; &#125; dfs ( s , 0 , 1 ) ; while ( m -- ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; printf ( &quot;%d\\n&quot; , LCA ( x , y ) ) ; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"LCA","slug":"LCA","permalink":"http://1152396492.github.io/tags/LCA/"}]},{"title":"线段树","slug":"线段树","date":"2021-11-27T17:12:43.000Z","updated":"2021-12-25T08:27:21.245Z","comments":true,"path":"2021/11/28/线段树/","link":"","permalink":"http://1152396492.github.io/2021/11/28/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"线段树是一种树状数据结构，它可以区间加减，区间乘除等一系列操作，用于处理那种可以合并状态的数据，在使用其3倍左右的空间的代价下使得其修改、查询、求区间和等等操作变得更加快捷。但与此同时，我们无法利用它处理类似于区间最长01序列此类问题，而且线段树代码冗长，其实很容易写错（也可能是因为我太菜了）。我们将一组数据进行如下处理，每相邻的两个数据有一个父亲节点来记录其总的状态，然后再记录其相邻父节点的总的状态，以此类推，最终得到一个树状结构，我们从上到下依次编号1-n，这棵树满足父节点*2=左节点，父节点*2+1=右节点，设每个父节点代表l-r区间的状态，则左区间为l,(r+l)/2 , 右区间为(r+l)/2+1,r。根据此性质我们可以对他们进行维护。每当我们访问一个节点，我们保证此节点的值一定正确，并尽可能少的改变其子孙节点的值，让时间消耗尽可能的小，同时把lazy标记也就是本来应该加的数传递到下一节点。第一颗树实现了区间加与查询，第二颗树实现了区间乘法，加法，判断其中的先后顺序，其实也大同小异。第三颗树用于实现历史最大值这种操作，然而由于本人电脑跑不动500mb的程序，再加之修改起来有点麻烦，就写个大致正确的程序摆在这了。如果要继续完善，那么需要记录次大值并对于spread函数进行修改，就这样吧，后面再来补。","text":"线段树是一种树状数据结构，它可以区间加减，区间乘除等一系列操作，用于处理那种可以合并状态的数据，在使用其3倍左右的空间的代价下使得其修改、查询、求区间和等等操作变得更加快捷。但与此同时，我们无法利用它处理类似于区间最长01序列此类问题，而且线段树代码冗长，其实很容易写错（也可能是因为我太菜了）。我们将一组数据进行如下处理，每相邻的两个数据有一个父亲节点来记录其总的状态，然后再记录其相邻父节点的总的状态，以此类推，最终得到一个树状结构，我们从上到下依次编号1-n，这棵树满足父节点*2=左节点，父节点*2+1=右节点，设每个父节点代表l-r区间的状态，则左区间为l,(r+l)/2 , 右区间为(r+l)/2+1,r。根据此性质我们可以对他们进行维护。每当我们访问一个节点，我们保证此节点的值一定正确，并尽可能少的改变其子孙节点的值，让时间消耗尽可能的小，同时把lazy标记也就是本来应该加的数传递到下一节点。第一颗树实现了区间加与查询，第二颗树实现了区间乘法，加法，判断其中的先后顺序，其实也大同小异。第三颗树用于实现历史最大值这种操作，然而由于本人电脑跑不动500mb的程序，再加之修改起来有点麻烦，就写个大致正确的程序摆在这了。如果要继续完善，那么需要记录次大值并对于spread函数进行修改，就这样吧，后面再来补。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ; typedef long long LL ; const int maxn = 500005 ; struct L &#123; LL val , add ; &#125; t[maxn] ; LL n , m , a[maxn] ; void build ( int p , int l , int r ) &#123; if ( l == r ) &#123; t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; return ; &#125;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) , t[p&lt;&lt;1|1].add += t[p].add ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , int z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; &#125;LL ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; LL ans = 0 ; if ( x &lt;= mid ) ans = ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans = ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ; &#125;int main ( ) &#123; scanf ( &quot;%lld%lld&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%lld&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; for ( int i = 1 ; i &lt;= m ; i ++ ) &#123; int com , x , y ; scanf ( &quot;%d%d%d&quot; , &amp; com , &amp; x , &amp; y ) ; if ( com == 1 ) &#123; LL k ; scanf ( &quot;%lld&quot; , &amp; k ) ; change ( 1 , 1 , n , x , y , k ) ; &#125; else printf ( &quot;%lld\\n&quot; , ask ( 1 , 1 , n , x , y ) ) ; &#125; return 0 ; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 100003 ;typedef long long ll ;inline int read ( ) &#123; char ch = getchar ( ) ; int res = 0 ; while ( ch &gt; &#x27;9&#x27; || ch &lt; &#x27;0&#x27; ) ch = getchar ( ) ; while ( ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27; ) res = res * 10 + ch - 48 , ch = getchar ( ) ; return res ;&#125;struct L &#123; ll mul , val , add ;&#125; t[N&lt;&lt;2] ;int n , m , a[N] , mod ;void build ( int p , int l , int r ) &#123; t[p].mul = 1 ; if ( l == r ) &#123; t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;void spread ( int p , int l , int r ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val * t[p].mul + t[p].add * ( mid - l + 1 ) ) % mod ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val * t[p].mul + t[p].add * ( r - mid ) ) % mod ; t[p&lt;&lt;1].mul = ( t[p&lt;&lt;1].mul * t[p].mul ) % mod ; t[p&lt;&lt;1|1].mul = ( t[p&lt;&lt;1|1].mul * t[p].mul ) % mod ; t[p&lt;&lt;1].add = ( t[p&lt;&lt;1].add * t[p].mul + t[p].add ) % mod ; t[p&lt;&lt;1|1].add = ( t[p&lt;&lt;1|1].add * t[p].mul + t[p].add ) % mod ; t[p].mul = 1 ; t[p].add = 0 ;&#125;void change2 ( int p , int l , int r , int x , int y , ll z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].mul = ( t[p].mul * z ) % mod ; t[p].add = ( t[p].add * z ) % mod ; t[p].val = ( t[p].val * z ) % mod ; return ; &#125; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; if ( x &lt;= mid ) change2 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;void change1 ( int p , int l , int r , int x , int y , ll z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].add = ( t[p].add + z ) % mod ; t[p].val = ( t[p].val + ( r - l + 1 ) * z ) % mod ; return ; &#125; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; if ( x &lt;= mid ) change1 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change1 ( p &lt;&lt; 1 | 1, mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;ll aska ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) return t[p].val ; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; ll ans = 0 ; if ( x &lt;= mid ) ans += aska ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( mid &lt; y ) ans += aska ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; ans %= mod ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ; return ans ;&#125;int main ( ) &#123; n = read ( ) ; m = read ( ) ; mod = read ( ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; while ( m -- ) &#123; int command = read ( ) ; ll x = read ( ) , y = read ( ) ; if ( command == 1 ) change2 ( 1 , 1 , n , x , y , read ( ) ) ; if ( command == 2 ) change1 ( 1 , 1 , n , x , y , read ( ) ) ; if ( command == 3 ) cout &lt;&lt; aska ( 1 , 1 , n , x , y ) &lt;&lt; endl ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std ; const int maxn = 2000006 ; typedef long long LL ; struct L &#123; LL val , maxa , maxb , add , mina ;&#125; t[maxn] ;LL a[maxn&gt;&gt;2] ; void build ( int p , int l , int r ) &#123; t[p].mina = 0x7fffffff ; if ( l == r ) &#123; t[p].maxa = t[p].maxb = t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; &#125;void spread ( int p , int l , int r ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; //这里有一定的问题，需要判断变为最小的影响，需要分类讨论，其余的没有问题（大概） t[p&lt;&lt;1].val = min ( t[p].mina , ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) ) ; t[p&lt;&lt;1|1].val = min ( t[p].mina , ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) ) ; //持续到这里 t[p&lt;&lt;1].maxa = max ( t[p&lt;&lt;1].maxa + t[p].add , t[p].mina == 0x7fffffff ? 0 : t[p].mina ) ; t[p&lt;&lt;1|1].maxa = max ( t[p&lt;&lt;1|1].maxa + t[p].add , t[p].mina == 0x7fffffff ? 0 : t[p].mina ) ; t[p&lt;&lt;1].maxb = max( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1].maxa ) ; t[p&lt;&lt;1|1].maxb = max ( t[p&lt;&lt;1|1].maxb , t[p&lt;&lt;1|1].maxa ) ; t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].add += t[p].add ; t[p&lt;&lt;1].mina = min ( t[p&lt;&lt;1].mina , t[p].mina ) ; t[p&lt;&lt;1|1].mina = min ( t[p&lt;&lt;1|1].mina , t[p].mina ) ; t[p].mina = 0x7fffffff ; t[p].add = 0 ; &#125;void change1 ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].maxa += z ; t[p].maxb = max ( t[p].maxb , t[p].maxa ) ; t[p].val = ( t[p].val + z * ( r - l + 1 ) ) ; t[p].add += z ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change1 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change1 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; &#125;void change2 ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val = min ( t[p].val , z * ( r - l + 1 ) ) ; t[p].maxa = min ( z , t[p].maxa ) ; t[p].mina = z ; t[p].maxb = max ( t[p].maxb , t[p].maxa ) ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change2 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; &#125;LL ask1 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0 ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans += ask1 ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans += ask1 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ; &#125;LL ask2 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].maxa ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0x7fffffff ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans = min ( ans , ask2 ( p &lt;&lt; 1 , l , mid , x , y ) ) ; if ( y &gt; mid ) ans = min ( ans , ask2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) ; return ans ; &#125;LL ask3 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].maxb ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0x7fffffff ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans = min ( ans , ask3 ( p &lt;&lt; 1 , l , mid , x , y ) ) ; if ( y &gt; mid ) ans = min ( ans , ask3 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) ; return ans ; &#125;int main ( ) &#123; int n , m ; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%lld&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; while ( m -- ) &#123; int op ; scanf ( &quot;%d&quot; , &amp; op ) ; if ( op == 1 ) &#123; int l , r ; LL k ; scanf ( &quot;%d%d%lld&quot; , &amp; l , &amp; r , &amp; k ) ; change1 ( 1 , 1 , n , l , r , k ) ; &#125; else if ( op == 2 ) &#123; int l , r ; LL k ; scanf ( &quot;%d%d%lld&quot; , &amp; l , &amp; r , &amp; k ) ; change2 ( 1 , 1 , n , l , r , k ) ; &#125; else if ( op == 3 ) &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask1 ( 1 , 1 , n , l , r ) ) ; &#125; else if ( op == 4 ) &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask2 ( 1 , 1 , n , l , r ) ) ; &#125; else &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask3 ( 1 , 1 , n , l , r ) ) ; &#125; &#125; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"线段树","slug":"线段树","permalink":"http://1152396492.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Dijkstra","slug":"Dijkstra","date":"2021-11-27T15:44:01.000Z","updated":"2021-12-25T08:27:14.228Z","comments":true,"path":"2021/11/27/Dijkstra/","link":"","permalink":"http://1152396492.github.io/2021/11/27/Dijkstra/","excerpt":"Dijkstra算法用于解决单源最短路问题，假设起始点为S，在最开始我们可以知道S到某些点的距离，从中取出最小的一个，我们可以保证在我们取出这个最小值的时候不可能有任何路径可以更短的到达此点，，此过程使用了贪心的思想。每当我们找出一个这样的点就更新S到与此点相连的其它点的距离，我们每一次取点都保证取出的是最短的且未被访问的点，这就是Dijkstra算法。","text":"Dijkstra算法用于解决单源最短路问题，假设起始点为S，在最开始我们可以知道S到某些点的距离，从中取出最小的一个，我们可以保证在我们取出这个最小值的时候不可能有任何路径可以更短的到达此点，，此过程使用了贪心的思想。每当我们找出一个这样的点就更新S到与此点相连的其它点的距离，我们每一次取点都保证取出的是最短的且未被访问的点，这就是Dijkstra算法。 网上对于Dijkstra的优缺点有很好的描述我就直接引用了： 优点:O(N*N),加堆优化:O(N*logN)缺点: 在单源最短路径问题的某些实例中，可能存在权为负的边。如果图G＝（V，E）不包含从源s可达的负权回路，则对所有v∈V，最短路径的权定义d(s,v)依然正确，即使它是一个负值也是如此。但如果存在一从s可达的负回路，最短路径的权的定义就不能成立。S到该回路上的结点就不存在最短路径。当有向图中出现负权时，则Dijkstra算法失效。当不存在源s可达的负回路时，我们可用Bellman-Ford算法实现。————————————————版权声明：本文为CSDN博主「Chandery」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/cdy1206473601/article/details/52648619 下面贴上我年轻时写的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ; const int maxn = 5000000 ;int head[maxn] , nex[maxn] , to[maxn] , val[maxn] , cnt = 0 ; int vis[maxn] , dis[maxn] ; struct L &#123; int val , id ; bool operator &lt; ( const L &amp; x ) const &#123; return val &gt; x.val ; &#125;&#125; ; void add ( int x , int y , int z ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; val[cnt] = z ; &#125; void dijkstra ( int s ) &#123; priority_queue &lt; L &gt; Q ; Q.push ( ( L ) &#123; 0 , s &#125; ) ; dis[s] = 0 ; while ( ! Q.empty ( ) ) &#123; L u = Q.top ( ) ; int x = u.id ; Q.pop ( ) ; if ( vis[x] ) continue ; vis[x] = 1 ; for ( int i = head[x] ; i ; i = nex[i] ) &#123; if ( dis[to[i]] &gt; dis[x] + val[i] ) &#123; dis[to[i]] = dis[x] + val[i] ; if ( ! vis[to[i]] ) Q.push ( ( L ) &#123; dis[to[i]] , to[i] &#125; ) ; &#125; &#125; &#125;&#125;int main ( ) &#123; int n , m , s ; scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ; for ( int i = 1 ; i &lt;= m ; i ++ ) &#123; int x , y , z ; scanf ( &quot;%d%d%d&quot; , &amp; x , &amp; y , &amp; z ) ; add ( x , y , z ) ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) dis[i] = 0x7fffffff ; dijkstra ( s ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) printf ( &quot;%d &quot; , dis[i] ) ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://1152396492.github.io/tags/Dijkstra/"}]},{"title":"平时抽风写的诗","slug":"平时抽风写的诗","date":"2021-11-26T21:43:09.000Z","updated":"2022-01-08T11:43:16.313Z","comments":true,"path":"2021/11/27/平时抽风写的诗/","link":"","permalink":"http://1152396492.github.io/2021/11/27/%E5%B9%B3%E6%97%B6%E6%8A%BD%E9%A3%8E%E5%86%99%E7%9A%84%E8%AF%97/","excerpt":"这些诗也不是有意写出来的，有些时候情绪到了，突然之间有感觉了，也就写出来了。虽然我知道写的很烂，因为毕竟我即没有大量的阅读现代诗，也没有经过专门的写作训练，但情绪对了，不也达到了目的嘛","text":"这些诗也不是有意写出来的，有些时候情绪到了，突然之间有感觉了，也就写出来了。虽然我知道写的很烂，因为毕竟我即没有大量的阅读现代诗，也没有经过专门的写作训练，但情绪对了，不也达到了目的嘛 细雨朦胧的上午回寝室的路上耳机里传来的是回忆是过去的情绪 不断跳过又不舍删去的歌如今也能静静凝听这意味着成长也意味着失去 《梦》没有任何犹豫把朋友抛下只因望见她的身影 “原来你和我在同一座城市”对于她撒谎这件事心中委屈却毫无芥蒂 明知道她在微笑可为什么我怎么也看不清她的脸 恍惚中猛一转头无论梦里梦外人群里早已不见她的身影 在我初识算法时我一直认为人生不过是动态规划走好每一步即可可最后我发现人生是有后效性的它是无法穷尽的搜索可能我一直都是鼠目寸光吧然而我们永远不会知道我们现在干的事对将来有什么影响我们永远也不会重来自以为对未来的把握很可笑不是吗或许鼠目寸光也不错毕竟我们能享受当下 强者与斗士的区别类似于智者与伟人我更欣赏与羡慕后者因为他们有着无可比拟的信念信念支撑着他们但生活却挫败着他们但这并不重要或许后来斗士不再善战伟人的行为变得愚蠢甚至他们自身的信念也被生活磨砺光滑但是他们的信念传承了下去激励了千千万万的人这是前两者所不能比的 ps：托尼弗格森，我最欣赏的斗士，人民的英雄","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"诗","slug":"诗","permalink":"http://1152396492.github.io/tags/%E8%AF%97/"}]},{"title":"结构","slug":"结构","date":"2021-11-22T21:02:31.000Z","updated":"2023-11-14T01:53:21.931Z","comments":true,"path":"2021/11/23/结构/","link":"","permalink":"http://1152396492.github.io/2021/11/23/%E7%BB%93%E6%9E%84/","excerpt":"结构的基本知识结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在ANSI标准中，自动结构和数组现在也可以进行初始化。","text":"结构的基本知识结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在ANSI标准中，自动结构和数组现在也可以进行初始化。 我们首先来看一个关于平面坐标的结构体 123struct point &#123; int x , y ; &#125; ; 关键字struct引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字struct后面的名字是可选的，称为结构标记（这里是point）。结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。结构中定义的变量称为成员。结构成员，结构标记和普通变量（即非成员）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。不同结构中的成员也可以使用相同的名字。struct声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其它基本类型的变量声明是相同的。例如： 1struct &#123; ... &#125; x , y , z ; 从语法角度来说，这种声明与声明 1int x , y , z ; 具有类似的意义。如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如： 1struct point maxpt = &#123; 320 , 200 &#125; ; 定义了一个struct point类型的变量pt。结构的初始化可以在定义的后面使用初值表进行，除指标中同每个成员对应的处置必须是常量表达式。自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构中的成员。在表达式中可以通过下列形式引用某哥特定结构中的成员：结构名.成员结构可以嵌套，例如 12345struct rect &#123; struct point pt1 ; struct point pt2 ; &#125; ;struct rec screen ; 我们可以使用语句 1screen.pt1.x ; 结构与函数结构的合法操作只有： 作为一个整体赋值 通过&amp;运算符取地址，访问其成员。 其中复制和复制包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。我们可以通过至少3种方法传递结构： 分别传递各个结构成员 传递整个结构 传递指向结构的指针 例如以下函数 123456789101112131415161718struct point makepoint ( int x , int y ) &#123; struct point temp ; temp.x = x ; temp.y = y ; return temp ; &#125;struct rect screen ; struct point middle ; struct point makepoint ( int , int ) ; screen.pt1 = makepoint ( 0 , 0 ) ; screen.pt2 = makepoint ( XMAX , YMAX ) ; middle = makepoint ( ( screen.pt1.x + screen.pt2.x ) &gt;&gt; 1 , ( screen.pt1.y + screen.pt2.y ) &gt;&gt; 1 ) ; struct point addpoint ( struct point p1 , struct point p2 ) &#123; p1.x += p2.x ; p1.y += p2.y ; return p1 ; &#125; addpoint 函数的参数和返回值都是结构类型，结构类型的参数和其它参数是一样的都是通过值传递的。 如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率更高，结构指针类似于普通变量指针。声明： 1struct point * pp ; 如果pp指向一个point结构，那么 * pp 即为该结构，而（ * pp ).x 和( * pp ).y则是结构成员。其中( * pp ).x 的圆括号是必须的，因为结构成员运算符”.”的优先级比”*“的优先级高。表达式*pp.x的含义等价于*(pp.x)，因为x不是指针，所以该表达式是非法的。结构指针的使用频率非常高，为了使用方便，C语言提供了另一种简写方式。嘉定p是一个指向结构的指针，可以用p-&gt;结构成员这种形式来引用相应的结构成员。运算符.和-&gt;都是从左至右结合的，所以以下声明都是等价的： 123456struct rec r , * rp = &amp; r ; r.pt1.x rp-&gt;pt1.x (r.pt1).x (rp-&gt;pt1).x 在所有运算符中，下面 4 个运算符的优先级最高：结构运算符“.”和“-&gt;”、用于函数调用的“()”以及用于下标的“[]”，因此，它们同操作数之间的结合也最紧密。例如，对于结构声明 1234struct &#123; int len; char *str; &#125; *p ; 表达式 1++p-&gt;len 将增加 len 的值，而不是增加 p 的值，这是田为，其中的隐含括号关系是++(p-&gt;len)。可 以使用括号改变结合次序。例如：(++p)-&gt;len 将先执行 p 的加 1 操作，再对 len 执行操作； 而(p++)-&gt;len 则先对 len 执行操作，然后再将 p 加 1（该表达式中的括号可以省略）。 同样的道理，*p-&gt;str 读取的是指针 str 所指向的对象的值；*p-&gt;str++先读取指针str 指向的对象的值，然后再将 str 加 1（与*s++相同）；(*p-&gt;str）++将指针 str 指向 的对象的值加 1；*p++-&gt;str 先读取指针 str 指向的对象的值，然后再将 p 加 1。 结构数组考虑编写一个程序，用来统计输入中各个C语言关键字出现的次数。 1234567891011121314151617struct key &#123; char *word; int count;&#125; keytab[] = &#123; &quot;auto&quot;, 0, &quot;break&quot;, 0, &quot;case&quot;, 0, &quot;char&quot;, 0, &quot;const&quot;, 0, &quot;continue&quot;, 0, &quot;default&quot;, 0, /* ... */ &quot;unsigned&quot;, 0, &quot;void&quot;, 0, &quot;volatile&quot;, 0, &quot;while&quot;, 0&#125;; 与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结构）的初值都括在花括号内，如下所示： 1234&#123; &quot;auto&quot;, 0 &#125;, &#123; &quot;break&quot;, 0 &#125;, &#123; &quot;case&quot;, 0 &#125;, ... 但是，如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省 略。通常情况下，如果初值存在并且方括号[ ]中没有数值，编译程序将计算数组 keytab 中 的项数。在统计关键字出现次数的程序中，我们首先定义了 keytab。主程序反复调用函数getword 读取输入，每次读取一个单词。每个单词将通过折半查找函数在keytab 中进行查找。注意，关键字列表必须按升序存储在 keytab 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100int getword(char *, int);int binsearch(char *, struct key *, int);/* count C keywords */int main()&#123; int n; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0) keytab[n].count++; for (n = 0; n &lt; NKEYS; n++) if (keytab[n].count &gt; 0) printf(&quot;%4d %s\\n&quot;, keytab[n].count, keytab[n].word); return 0;&#125;/* binsearch: find word in tab[0]...tab[n-1] */int binsearch(char *word, struct key tab[], int n)&#123; int cond; int low, high, mid; low = 0; high = n - 1; while (low &lt;= high) &#123; mid = (low+high) / 2; if ((cond = strcmp(word, tab[mid].word)) &lt; 0) high = mid - 1; else if (cond &gt; 0) low = mid + 1; else return mid; &#125; return -1;&#125;int getword ( char * word , int lim ) &#123; int c , getch ( void ) ; void ungetch ( int ) ; char * w = word ; while ( isspace ( c = getch ( ) ) ) ; if ( c != EOF ) * w ++ ; if ( ! isalpha ( c ) ) &#123; * w = &#x27;\\0&#x27; ; return c ; &#125; for ( ; -- lim &gt; 0 ; w ++ ) if ( ! isnum ( * w = getch ( ) ) ) &#123; ungetch ( * w ) ; break ; &#125; * w = &#x27;\\0&#x27; ; return word[0] ; &#125;/*我们可以通过如下方法计算NKEYS的值*/#define NKEYS ( sizeof keytab / sizeof ( struct key ) ) #define NKEYS ( sizeof keytab / sizeof keytab[0] ) getchar函数的返回值也是int类型的 指向结构的指针1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #define MAXWORD 100 int getword(char *, int); struct key *binsearch(char *, struct key *, int); /* count C keywords; pointer version */ int main() &#123; char word[MAXWORD]; struct key *p; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((p=binsearch(word, keytab, NKEYS)) != NULL) p-&gt;count++; for (p = keytab; p &lt; keytab + NKEYS; p++) if (p-&gt;count &gt; 0) printf(&quot;%4d %s\\n&quot;, p-&gt;count, p-&gt;word); return 0; &#125; /* binsearch: find word in tab[0]...tab[n-1] */ struct key *binsearch(char *word, struck key *tab, int n) &#123; int cond; struct key *low = &amp;tab[0]; struct key *high = &amp;tab[n]; struct key *mid; while (low &lt; high) &#123; mid = low + (high-low) / 2; if ((cond = strcmp(word, mid-&gt;word)) &lt; 0) high = mid; else if (cond &gt; 0) low = mid + 1; else return mid; &#125; return NULL; &#125; 这一个部分比较简单，就不细写了，上面的程序等于是改写了一下。搜索函数里面的while循环是为了防止死循环写的，当high==low的时候，如果没有low&lt;high这个条件会一直死循环下去。特别需要注意的是千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要 求，所以，结构中可能会出现未命名的“空穴“（hole）。例如，假设 char 类型占用一个字节，int 类型占用 4 个字节，则下列结构： 1234struct &#123; char c; int i; &#125;; 可能需要 8 个字节的存储空间，而不是 5 个字节。使用 sizeof 运算符可以返回正确的对象长度。 自引用结构假定我们需要处理一个更一般化的问题：统计输入中所有单词的出现次数。因为预先不 知道出现的单词列表，所以无法方便地排序，并使用折半查找；也不能分别对输入中的每个单词都执行一次线性查找，看它在前面是否已经出现，这样做，程序的执行将花费太长的时 间。（更准确地说，程序的执行时间是与输入单词数目的二次方成比例的。）我们该如何组织这些数据，才能够有效地处理一系列任意的单词呢？一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终 保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现，但它仍 然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。 每个不同的单词在树中都是一个节点，每个节点包含： 一个指向该单词内容的指针 一个统计出现次数的计数值 · 一个指向左子树的指针 一个指向右子树的指针任何节点最多拥有两个子树，也可能只有一个子树或一个都没有。 对节点的所有操作要保证，任何节点的左子树只包含按字典序小于该节点中单词的那些单词，右子树只包含按字典序大于该节点中单词的那些单词。要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。若 匹配，则得到肯定的答案。若新单词小于该节点中的单词，则在左子树中继续查找，否则在 右子树中查找。如在搜寻方向上无子树，则说明新单词不在树中，并且，当前的空位置就是 存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。相应地，在插入和打印操作中使用递归过程也是很自然的事情。对节点的递归的：","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://1152396492.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"结构","slug":"结构","permalink":"http://1152396492.github.io/tags/%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-07T03:13:05.507Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/11/07/hello-world/","link":"","permalink":"http://1152396492.github.io/2021/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"指针","slug":"指针","date":"2021-11-04T08:48:35.000Z","updated":"2023-11-14T01:56:19.656Z","comments":true,"path":"2021/11/04/指针/","link":"","permalink":"http://1152396492.github.io/2021/11/04/%E6%8C%87%E9%92%88/","excerpt":"指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。","text":"指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。 指针与地址一元运算符&amp;可用于取一个对象的地址 1p = &amp; c ; 将把 c 的地址赋值给变量 p，我们称 p 为“指向”c 的指针。地址运算符&amp;只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。下列程序介绍了&amp;与 * 的使用方法 12345int x = 1 , y = 2 , z[10] ; ip = &amp; x ; //表明表达式*ip 的结果是 int 类型。y = * ip ; * ip = 0 ; ip = &amp; z[0] ; 对函数的声明也可以采用这种方式。例如，声明 1double *dp，atof(char *); 表明，在表达式中，*dp 和 atof(s)的值都是 double 类型，且 atof 的参数是一个指向 char类型的指针。指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。)如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用 * ip，因此， 语句 1*ip = *ip + 10; 将把ip 的值增加 10。 一元运算符和&amp;的优先级比算术运算符的优先级高，因此，赋值语句 1y = *ip + 1 将把*ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句： 1*ip += 1 则将 ip 指向的对象的值加 1，它等同于 1++*ip 或 1(*ip)++ 语句的执行结果。语句( * ip)++中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于*和++这样的一元运算符遵循从右 至左的结合顺序。最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句 1iq = ip 将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。 指针与指针参数为了使被调用函数直接修改主调函数中的变量值，我们可以使主调程序将指向所要交换的变量的指针传递给被调用函数，即： 1swap ( &amp; a , &amp; b ) ; 由于一元运算符&amp;用来取变量的地址，这样&amp;a就是一个指向变量a的指针。swap函数的所有参数都声明为指针，并且通过这些指针来间接访问它们所指向的操作数。 123456void swap ( int * px , int * py ) &#123; int temp ; temp = * px ; * px = * py ; * py = temp ; &#125; 指针参数使得被调用函数能够访问和修改主调函数中对象的值。我们来看一个可以接受自由格式输入，并执行转换，并同时返回得到的整数和文件结束标志（EOF）的函数。如果你觉得你已经了解了可以不用看下面的代码，直接进入下一节。 123456789101112131415161718192021int getch ( void ) &#123; return ( bufp &gt; 0 ) ? buf[--bufp] : getchar ( ) ; &#125;void ungetch ( int c ) &#123; if ( bufp &gt;= BUFSIZE ) printf ( &quot;ungetch:too many characters\\n&quot; ) ; else buf[bufp++] = c ; &#125;int getint ( int * pn ) &#123; int c , sign ; while ( isspace ( c = getch ( ) ) ) ; if ( ! isdigit ( c ) &amp;&amp; c != EOF &amp;&amp; c != &#x27;+&#x27; &amp;&amp; c != &#x27;-&#x27; ) &#123; ungetch ( c ) ; return 0 ; &#125; sign = ( c == &#x27;-&#x27; ) ? -1 : 1 ; if ( c == &#x27;+&#x27; || c == &#x27;-&#x27; ) c = getch ( ) ; for ( * pn = 0 ; isdigit ( c ) ; c = getch ( ) ) * pn = 10 * * pn + c - &#x27;0&#x27; ; * pn *= sign ; if ( c != EOF ) ungetch ( c ) ; return c ; &#125; 在getint函数中，*pn始终作为一个普通的整形变量使用。 指针与数组一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解 起来稍微困难一些。声明 1int a[10]; 定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个对象存储在相邻的内存区域中，名字分别为 a[0]、a[1]、…、a[9]如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa所指向数组元素之后的第i个元素，而pa-i将指向pa所指向数组元素之前的第 i 个元素。因此，如果指针 pa 指向 a[0]，那么* (pa+1)引用的是数组元素a[1]的内容，pa+i 是数组元素 a[i]的地址，* (pa+i)引用的是数组元素 a[i]的内容无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1”就意味着，pa+1 指向 pa 所指向的对象的下一个对象。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。对数组元素 a[i]的引用也可以写成*(a+i)这种形式。对第一次接触这种写法的人来说， 可能会觉得很奇怪。在计算数组元素 a[i]的值时，C 语言实际上先将其转换为*(a+i)的形式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符&amp;，便可以得出这样的结论：&amp;a[i]和 a+i 的含义也是相同的。a+i 是 a之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa[i]与*(pa+i)是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C语言中，语句 pa=a 和 pa++都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a++形式的语句是非法的。当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值 的变量。 123456/*return length of s */int strlen ( char * s ) &#123; int n ; for ( n = 0 ; * s != &#x27;\\0&#x27; ; s ++ ) n ++ ; return n ; &#125; 执行 s++运算不会影响到 strlen 函数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。以下的函数调用均正确： 12345strlen ( &quot;hello world&quot; ) ;char array[100] ; strlen ( array ) ; char * ptr ; strlen ( ptr ) ; 在函数定义中，形式参数 1char s[]; 和 1char *s; 是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法。也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函数。例如，如果 a 是一个数组，那么下面两个函数调用 1f(&amp;a[2]) 与 1f(a+2) 都将把起始于 a[2]的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为 1f(int arr[]) &#123; ... &#125; 或 1f(int *arr) &#123; ... &#125; 对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。 如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于p[-1]、p[-2]这样的表达式在语法上都是合法的，它们分别引用位于 p[0]之前的两个元素。当然，引用数组边界之外的对象是非法的。 地址算术运算下面我们将给出函数alloc和afree，他们分别对标malloc.h头文件中的malloc函数和free函数，只是功能相对于malloc和free更菜而已。这里就先直接贴代码，看不懂也没关系，继续往下看就行 12345678910111213char * alloc ( int n ) &#123; if ( ( allocbuf + ALLOCSIZE - allocp &gt;= n ) ) &#123; allocp += n ; return allocp - n ; &#125; else return 0 ; //C语言保证，0永远不是有效的数据地址，因此返回值0可用来表示发生了异常事件&#125;void afree ( char * p ) &#123; if ( p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE ) allocp = p ; //对指针进行比较&#125; 首先，在某些情况下对指针可以进 行比较运算。例如，如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行类似 于==、!=、&lt;、&gt;=的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置 之前，那么关系表达式p &lt; q的值为真。任何指针与 0进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可使用数组最 后一个元素的下一个元素的地址。）其次。我们从前面可以看到，指针可以和整数进行相加或相减运算。例如，结构p + n表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元索，且 p&lt;q，那么 q-p+1就是位于 p 和 q 指向的元索之间的元素的数目。我们由此可以编写出函数 strlen 的另一个版本，如 12345int strlen ( char * s ) &#123; char * p = s ; while ( * p != &#x27;\\0&#x27; ) p ++ ; return p - s ; &#125; 字符指针与函数字符串常量是一个字符数组，例如： 1&quot;I am a string&quot; 在字符串的内部表示中，字符数组以空字符’\\0’结尾，所以，程序可以通过检查空字符找到 字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。字符串常量最常见的用法也许是作为函数参数，例如： 1princf(&quot;hello, world\\n&quot;&#125;; 当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。除了作为函数参数以外，字符串常量还有其它的用法。例如 12char *pmessage ; pmessage = &quot;now is the time&quot; ; 此操作把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只 是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。下面两个定义之间有很大的差别： 12char amessage[] = &quot;nw is the time&quot;; /* 定义一个数组 */ char *pmessage = &quot;now is the time&quot;; /* 定义一个指针 */ 上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符’\\0’的一维数组。数组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图 修改字符串的内容，结果是没有定义的掌握了上面的知识，我们现在可以理解下面的程序 1void strcpy ( char * s , char * t ) while ( * s ++ = * t ++ ) ; 1234int strcmp ( char * s , char * t ) &#123; for ( ; * s == * t ; s ++ , t ++ ) if ( * s == &#x27;\\0&#x27; ) return 0 ; return * s - * t ; &#125; 数组指针与指向指针的指针下面是一个运用快速排序来实现字符串排序的程序，qsort部分可自行使用快排实现，我自己想了想也可以用普通的sort + 结构体实现，或许会更好点，这里就不展开了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAXLINES 5000 /* max #lines to be sorted */ char *lineptr[MAXLINES]; /* pointers to text lines */ int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines); void qsort(char *lineptr[], int left, int right); /* sort input lines */ main() &#123; int nlines; /* number of input lines read */ if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; qsort(lineptr, 0, nlines-1); writelines(lineptr, nlines); return 0; &#125; else &#123; printf(&quot;error: input too big to sort\\n&quot;); return 1; &#125; &#125; #define MAXLEN 1000 /* max length of any input line */ int getline(char *, int); char *alloc(int); /* readlines: read input lines */ int readlines(char *lineptr[], int maxlines) &#123; int len, nlines; char *p, line[MAXLEN]; nlines = 0; while ((len = getline(line, MAXLEN)) &gt; 0) if (nlines &gt;= maxlines || p = alloc(len) == NULL) return -1; else &#123; line[len-1] = &#x27;\\0&#x27;; /* delete newline */ strcpy(p, line); lineptr[nlines++] = p; &#125; return nlines; &#125; /* writelines: write output lines */ void writelines(char *lineptr[], int nlines) &#123; int i; for (i = 0; i &lt; nlines; i++) printf(&quot;%s\\n&quot;, lineptr[i]); &#125;void qsort(char *v[], int left, int right) &#123; int i, last; void swap(char *v[], int i, int j); if (left &gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right)/2); last = left; for (i = left+1; i &lt;= right; i++) if (strcmp(v[i], v[left]) &lt; 0) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last-1); qsort(v, last+1, right); &#125;/* swap: interchange v[i] and v[j] */ void swap(char *v[], int i, int j) &#123; char *temp; temp = v[i]; v[i] = v[j]; v[j] = temp; &#125; 在该例子中，指针数组 lineptr 的声明是新出现的重要概念： 1char *lineptr[MAXLINES]; 它表示 lineptr 是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，lineptr[i]是一个字符指针，而*lineptr[i]是该指针指向的第 i 个文本行的首字符。 由于 lineptr 本身是一个数组名，因此，可按照前面例子中相同的方法将其作为指针使用，这样，writelines 函数可以改写为： 123456/* writelines: write output lines */ void writelines(char *lineptr[], int nlines) &#123; while (nlines-- &gt; 0) printf(&quot;%s\\n&quot;, *lineptr++); &#125; （注意这里的数组变量 lineptr 可以改变值）循环开始执行时，*lineptr 指向第一行，每执行一次自增运算都使得 lineptr 指向下 一行，同时对 nlines 进行自减运算。 多维数组如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针，它指向由行 向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组。在该例子中，传递 给函数的是一个指向很多对象的指针，其中每个对象是由 13 个整型元素构成的一维数组。因 此，如果将数组 daytab 作为参数传递给函数 f，那么 f 的声明应该写成下列形式： 1f(int daytab[2][13]) &#123; ... &#125; 也可以写成 1f(int daytab[][13]) &#123; ... &#125; 因为数组的行数无关紧要，所以，该声明还可以写成 1f(int (*daytab)[13]) &#123; ... &#125; 这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号[]的优先级高于*的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成 1int *daytab[13] 这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。 指针数组的初始化考虑这样一个问题：编写一个函数 month_name(n)，它返回一个指向第 n 个月名字的 字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一 个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始化该名字数组。指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似： 1234567891011/* month_name: return name of n-th month */ char *month_name(int n) &#123; static char *name[] = &#123; &quot;Illegal month&quot;, &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; &#125;; return name ; 其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字 符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应 位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在name[i]中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进 行统计，并将这一准确数字填入数组的长度。 指针与多维数组对于 C 语言的初学者来说，很容易混淆二维数组与指针数组之间的区别，比如上面例子 中的 name。假如有下面两个定义： 12int a[10][20]; int \\*b[10]; 那么，从语法角度讲，a[3][4]和 b[3][4]都是对一个 int 对象的合法引用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间，并且通过常规的矩阵下标计算公式 20×row+col（其中，row 表示行，col 表示列）计算得到元素 a[row][col]的位置。但是，对 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化，它们的初始化必须以显式的方式进行，比如静态初始化或通过代码初始化。假定 b 的每个元素(其实只取决于最大的）都指向一个具有 20 个元 素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b 的每个元素不 必都指向一个具有 20 个元素的向量，某些元素可以指向具有 2 个元素的向量，某些元素可以指向具有 50 个元素的向量，而某些元素可以不指向任何向量。 命令行参数编程实际场景中感觉是不常用的，我自己也没看懂，日后补略 指向函数的指针在系统学习完指向含糊的指针后，我发现这玩意就是个纸老虎，只是听起来挺高大上的，其实非常简单。在实际运用中就差不多减少一点代码行数而已，感觉替代性挺强的。（也可能是因为我太菜了）那就开始吧在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。我们接下来将修改排序函数，在给定可选参数-n的情况下，该函数将按树枝大小而非字典顺序对输入行进行排序。排序程序通常包括3部分：判断任何两个对象之间次序的比较操作、颠倒对象次序的交 换操作、一个用于比较和交换对象直到所有对象都按正确次序排列的排序算法。由于排序算法与比较、交换操作无关，因此，通过在排序算法中调用不同的比较和交换函数，便可以实 现按照不同的标准排序。这就是我们的新版本排序函数所采用的方法。函数 strcmp 按字典顺序比较两个输入行。在这里，我们还需要一个以数值为基础来比较两个输入行，并返回与 strcmp 同样的比较结果的函数 numcmp。这些函 数在 main 之前声明，并且，指向恰当函数的指针将被传递给 qsort 函数。在这里，参数的出错处理并不是问题的重点，我们将主要考虑指向函数的指针问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLINES 5000 /* max #lines to be sorted */char *lineptr[MAXLINES]; /* pointers to text lines */int readlines(char *lineptr[], int nlines);void writelines(char *lineptr[], int nlines);void qsort(void *lineptr[], int left, int right,int (*comp)(void *, void *));int numcmp(char *, char *);/* sort input lines */int main(int argc, char *argv[])&#123; int nlines; /* number of input lines read */ int numeric = 0; /* 1 if numeric sort */ if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0) numeric = 1; if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; qsort((void**) lineptr, 0, nlines-1, (int (*)(void*,void*))(numeric ? numcmp : strcmp)); writelines(lineptr, nlines); return 0; &#125; else &#123; printf(&quot;input too big to sort\\n&quot;); return 1; &#125;&#125;/* qsort: sort v[left]...v[right] into increasing order */void qsort(void *v[], int left, int right,int (*comp)(void *, void *))&#123; int i, last; void swap(void *v[], int, int); if (left &gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right)/2); last = left; for (i = left+1; i &lt;= right; i++) if ((*comp)(v[i], v[left]) &lt; 0) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last-1, comp); qsort(v, last+1, right, comp);&#125; 在调用函数qsort的语句中，strcmp和numcmp是函数的地址，因为它们是函数，所以前面不需要加上取地址运算符&amp;，同样的原因，数组名前面也不需要&amp;运算符。改写后的 qsort 函数能够处理任何数据类型，而不仅仅限于字符串。从函数 qsort 的 原型可以看出，它的参数表包括一个指针数组、两个整数和一个有两个指针参数的函数。其中，指针数组参数的类型为通用指针类型 void 。由于任何类型的指针都可以转换为 void类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用 qsort 函数时可以将参数强制转换为 void *类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。 1int ( * comp ) ( void * , void * ) 它表明comp是一个指向函数的指针，该函数具有两个void * 类型的参数，其返回值为int。值得注意的是圆括号是必须的，这样才能保证其中的各个部分正确结合，如果没有括号，如 1int * comp ( void * , void * ) 则表明comp是一个函数，该函数返回一个指向int类型的指针我们在前面讲过函数 strcmp，占用于比较两个字符串。这里介绍的函数 numcmp 也是比 较两个字符串，但它通过调用 atof 计算字符串对应的数值，然后在此基础上进行比较： 1234567891011121314#include &lt;stdlib.h&gt;/* numcmp: compare s1 and s2 numerically */int numcmp(char *s1, char *s2)&#123; double v1, v2; v1 = atof(s1); v2 = atof(s2); if (v1 &lt; v2) return -1; else if (v1 &gt; v2) return 1; else return 0;&#125; 交换两个指引的 swap 函数和本章前面所述的 swap 函数相同，但它的参数声明为 void *类型。 1234567void swap(void * v[], int i, int j;)&#123; void *temp; temp = v[i]; v[i] = v[j]; v[j] = temp;&#125; 链表关于malloc： 函数原型：1extern void \\*malloc(unsigned int num\\_bytes); malloc函数返回值如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 malloc函数使用注意事项malloc函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。在使用malloc开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。在使用malloc函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;malloc.h&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std ; struct node &#123; int value ; struct node * next ; &#125; ; typedef struct node Node ; //创造节点Node * create_node ( Node * head , int value ) &#123; Node * t_node = ( Node * ) malloc ( sizeof ( Node ) ) ; //千万不可自己去计算数据填入!!! if ( ! t_node ) &#123; printf ( &quot;failed&quot; ) ; exit ( -1 ) ; &#125; t_node -&gt; value = value ; // ( * t_node ).value ; t_node -&gt; next = head ; // return t_node ; &#125;//搜索目标节点Node * search_node ( int val , Node * head ) &#123; for ( Node * p = head ; p ; p = p -&gt; next ) &#123; if ( p -&gt; value == val ) return p ; &#125; return 0 ; &#125;//删除节点，直接越过目标节点进行连接Node * delete_node ( Node * head , int n ) &#123; Node * pre , * cur ; for ( pre = 0 , cur = head ; cur &amp;&amp; cur -&gt; value != n ; pre = cur , cur = cur -&gt; next ) ; if ( ! cur ) return head ; if ( ! pre ) head = head -&gt; next ; else pre -&gt; next = cur -&gt; next ; free ( cur ) ; cur = NULL ; //指向NULL养成好习惯 return head ; &#125;int main ( ) &#123; Node * head = 0 ; while ( 1 ) &#123; int val ; scanf ( &quot;%d&quot; , &amp; val ) ; if ( val == -1 ) break ; head = create_node ( head , val ) ; &#125; int find_val ; scanf ( &quot;%d&quot; , &amp; find_val ) ; Node * goal = search_node ( find_val , head ) ; return 0 ; &#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://1152396492.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://1152396492.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"小王子书评","slug":"小王子书评","date":"2021-10-10T15:02:22.000Z","updated":"2023-11-14T01:55:35.000Z","comments":true,"path":"2021/10/10/小王子书评/","link":"","permalink":"http://1152396492.github.io/2021/10/10/%E5%B0%8F%E7%8E%8B%E5%AD%90%E4%B9%A6%E8%AF%84/","excerpt":"国庆回家的火车上读完了《小王子》这本书，对于自从高三结束以来一直没有再阅读纸质小说的我来说，这的的确确是一种很新鲜的感觉，让我讶异的发觉，原来阅读是这么一种充实而快乐的体验。当然，打游戏远比此要快乐的多，这也是没办法的事，但以后当我没办法玩手机，也不妨多看看书吧。","text":"国庆回家的火车上读完了《小王子》这本书，对于自从高三结束以来一直没有再阅读纸质小说的我来说，这的的确确是一种很新鲜的感觉，让我讶异的发觉，原来阅读是这么一种充实而快乐的体验。当然，打游戏远比此要快乐的多，这也是没办法的事，但以后当我没办法玩手机，也不妨多看看书吧。 说回正题，《小王子》相比于我之前读的大部分书，都只能称作为侏儒，很难想象一本文字里面穿插了大量图画的书还没有《了不起的盖茨比》厚。两个小时不到，我就读完了它。我读到中间很多场景，都会不禁把书合上，静静的想上一会儿。这本书解决了我很多疑惑，尤其是对于现在的我来说是比较重要的一些问题，那就是如何处理与异性之间的关系，与朋友之间的关系，如何与他人建立亲密关系。《小王子》讲述了一位坠落在沙漠的飞行员，偶遇了来自其它星球的小王子，在与小王子的交谈中，为读者展现了小王子的过往。小王子的过往大致可分为三段，与玫瑰的过往，在星球之间遨游所看到的人与事，在地球上的经历，这里尤其是与狐狸发生的故事。这本书告诉我的一个最深刻的一个道理是：在不成熟的年纪，两情相悦不一定会带来好的结果。而在高三时，我一直以为自己足够成熟，懂得爱与被爱，可惜的是，我以为的成熟，不过仅仅达到了年轻时的小王子。这里的逻辑似乎很奇怪，如果说两个人彼此在乎，不应该主动走向彼此吗，为什么还会分离呢。在书中很生动的把它表现出来了，直接的原因是，我们并不知道对方在想什么。不知道对方在想什么，我们会猜测，对方是怎么看待我们的，我们会困惑，我们对对方做的一切是为了什么。而在这近乎上瘾的痛苦里，我们本能的会为了保护自己，选择逃避。即使我们会后悔。而根本的原因，书中也点出来了，我们太不成熟。就如同书中的玫瑰，为了让小王子心中只有她，明知这样会伤害到小王子，欺骗他说世上只有自己一朵玫瑰，无节制的使唤小王子，不把自己对小王子的爱给表露出来，直到小王子离开，就如同小王子，在悲伤中不理会玫瑰的种种，毅然决然的选择离开。我们不妨想想，是什么促使了小王子离开这个星球。长期的不理解让他们越来越远，以至于无法挽回，即使小王子当时留下来，他们恐怕也很难冰释前嫌，因为他们很难开口。所以小王子要去旅行，他一定要去磨砺自己，他一定要完全的失去玫瑰，他才会懂得珍惜。作者这里借小王子在不同星球穿越，阐发了自己对世界的看法，这里看似好像对整个故事来说可以省略似乎也不会有影响，但它是一个过渡，更是一个调味剂，也是我们所必须经历的一个阶段——我们必须去经历不同的事，见证不同的人，我们才会变得成熟。 未完","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"书评","slug":"书评","permalink":"http://1152396492.github.io/tags/%E4%B9%A6%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"插值算法","slug":"插值算法","date":"2021-10-03T16:21:52.000Z","updated":"2021-12-25T08:27:36.733Z","comments":true,"path":"2021/10/04/插值算法/","link":"","permalink":"http://1152396492.github.io/2021/10/04/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/","excerpt":"插值算法主要运用于在数学建模竞赛中，现有的数据极少，不足以支撑分析的进行，这时候就需要使用一些数学的方法插值的作用，“模拟产生”一些新的但又比较靠谱的值来满足需求","text":"插值算法主要运用于在数学建模竞赛中，现有的数据极少，不足以支撑分析的进行，这时候就需要使用一些数学的方法插值的作用，“模拟产生”一些新的但又比较靠谱的值来满足需求 一维插值问题问题如下：已经有n+1个节点(xi,yi)(i=0,1,…,n),其中xi互不相同，不妨设a &lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b ,求任一插值点x * （不等于xi）处的插值y *思路：构造y=f(x),使得f(x)过所有节点，即可得到y * 插值法的概念设函数y=f(x)在区间[a,b]上有定义，且已知在点a&lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b 上的值分别为 y0 , y1 , … , yn若存在一简单函数P(x)使P(xi) = yi ( i = 0 , 1 , 2 , … , n )则称P(x)为f(x)的插值函数，点x0,x1,…,xn称为插值节点，包含插值节点的区间[a,b]称为插值区间求插值函数P(x)的方法称为插值法插值法是不唯一的代数多项式：若P(x)是次数不超过n的代数多项式，即P(x) = a0 + a1x + … + anx^n分段插值：若P(x)为分段多项式，就称为分段插值三角插值：若P(x)为三角多项式，就称为三角插值（不予讨论）（一般要用到傅立叶变换等复杂的数学工具）一般来讲三角插值适用于对周期函数的插值（三角函数嘛） 插值法原理定理：设有n+1个互不相同的节点(xi,yi)(i=0,1,2,…,n)则存在唯一的多项式：Ln(x) = a0 + a1x + … + anx^n 使得Ln(xj) = yj (j=0,1,2,…n)证 构造方程组「a0 + a1x0 + … + anx0^n = y0a0 + a1x1 + … + anx1^n = y1…a0 + a1xn + … + anxn^n = yn 」 图片： 拉格朗日插值法在数值分析中，拉格朗日插值法是以法国十八世纪数学家约瑟夫·拉格朗日命名的一种多项式插值方法。如对实践中的某个物理量进行观测，在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。这样的多项式称为拉格朗日（插值）多项式。对于两个点:(x0,y0) , (x1,y1)f(x) = ( x - x1 ) y0 / ( x0 - x1 ) + ( x - x0 ) y1 / ( x1 - x0 )对于三个点:(x0,y0),(x1,y1),(x2,y2)f(x) = [ ( x - x1 ) ( x - x2 ) y0 ] / [ ( x0 - x1 ) ( x0 - x2 ) ] [ ( x - x0 ) ( x - x2 ) y1 ] / [ ( x1 - x0 ) ( x1 - x2 ) ] [ ( x - x0 ) ( x - x1 ) y2 ] / [ ( x2 - x0 ) ( x2 - x1 ) ]我们可以归纳发现，这种式子如果取其中的一个xi取得的值必定是yi，因为其它项为0，对应的xi的yi的系数必定为1然而我们实际情况中却不可能用拉格朗日插值法，他有很多问题龙格现象图片1:图片2:这引出了两个问题 插值多项式次数高，精度未必显著提高 插值多项式次数越高，摄入误差可能显著增大我们可以得到，对于高次的多项式插值时，如果我们不确定曲线的类型，我们尽量不要使用那么如何提高插值精度呢采用分段线性插值分段插值分段线性插值如果我们要在中间找一个值，我们找距离它最近的两点，两点之间连一条线段，直接在这条线段上找x对应的y值即可这种插值是十分简单的，也是不精准的分段二次插值分段二次插值也是非常简单的，我们可以寻找距离这个插入点最近的三个点，三个点可以形成一个二次函数，同理可以直接取二次函数的值分段二次插值又称为分段抛物线插值牛顿插值法·","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"插值算法","slug":"插值算法","permalink":"http://1152396492.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"}]},{"title":"TOPSIS-MATLAB","slug":"TOPSIS-MATLAB","date":"2021-09-22T18:35:13.000Z","updated":"2021-12-25T08:27:04.124Z","comments":true,"path":"2021/09/23/TOPSIS-MATLAB/","link":"","permalink":"http://1152396492.github.io/2021/09/23/TOPSIS-MATLAB/","excerpt":"代码如下","text":"代码如下 主函数代码12345678910111213141516171819202122232425262728clear;clcload data_water_quality.mat//正向化[n,m] = size ( X ) ;disp ( [&#x27;共有&#x27;num2str ( n ) &#x27;个评价对象,&#x27;num2str ( m ) &#x27;个评价指标] ) Judge = input ([&#x27;这&#x27;num2str(m)&#x27;个指标是否需要经过正向化处理，需要输入1，不需要输入0:&#x27;]);if Judge == 1 Position = input (&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]:&#x27;) ; disp ( &#x27;请输入需要处理的这些列的指标类型（1:极小型，2:中间型，3:区间型）&#x27;) Type = input (&#x27;例如2极小，3区间，6中间就输入[1,3,2]:&#x27; ) ; for i = 1 : size ( Position , 2 ) X ( : , Position ( i ) ) = Positivization ( X ( : , Position ( i ) ) , Type ( i ) , Position ( i ) ) ; //Positization是我们定义的函数 end disp (&#x27;正向化后的举证X=&#x27; ) disp ( X ) end//对正向化对举证进行标准化Z = X ./ repmat ( sum ( X .* X ) .^ 0.5 , n , 1 ) ;disp ( &#x27;标准化矩阵Z=&#x27; ） disp (Z) //计算最大值与最小值的距离，并算出得分D_P = sum ( [Z - repmat ( max ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; D_N = sum ( [Z - repmat ( min ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; S = D_N ./ ( D_P + D_N ) ; disp ( &#x27;最后的得分为：&#x27; ) stand_S = S / sum ( S ) [sorted_S , index] = sort ( stand_S , &#x27;descend&#x27; ) Positivization函数1234567891011121314151617181920212223function [ posit_x ] = Positivization ( x , type , i ) if type == 1 disp([&#x27;第&#x27;num2str ( i ) &#x27;列是极小型，正在正向化&#x27;]) posit_x = Min2Max ( x ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else if type == 2 dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是中间型&#x27;]) best = input (&#x27;请输入最佳的那一个值:&#x27;) ; posit_x = Mid2Max ( x , best ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ; disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else if type == 3 dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是区间型&#x27;]) a = input (&#x27;请输入区间的下界&#x27;) ; b = input (&#x27;请输入区间的上界&#x27;) ; posit_x = Inter2Max ( x , a , b ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ; disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else disp (&#x27;没有这种类型的指标请检查Type向量中是否有除了1、2、3以外的其他值&#x27;) endend Min2Max(x)函数123function [ posit_x ] = Min2Max ( x ) posit_x = max ( x ) - x ; end Mid2Max(x,best)函数1234function [ posit_x ] = Mid2Max ( x , best ) M = max ( abs ( x - best ) ) ; posit_x = 1 - abs ( x - best ) / M ; end Inter2Max(x,a,b)函数12345678910111213function [ posit_x ] = Inter2Max ( x , a , b ) ; M = max ([ a - min ( x ) , max ( x ) - b ] ) ; r_x = size ( x , 1 ) ; posit_x = zeros ( r_x , 1 ) ; for i = 1 : r_x if x(i) &lt; a posit_x(i) = 1 - ( a - x(i) ) / M ; else if x(i) &gt; b posit_x(i) = 1 - ( x(i) - b ) / M ; else posit_x(i) = 1 ; end endend 原始矩阵正向化将Excel内的数据直接粘贴进matlab里，赋值给变量将此变量另存为至与代码相同的目录下调用直接用load xxx.mat sort函数sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排序，sort(A)是默认的升序，而sort(A,’descend’)是降序若A是矩阵，默认对A的割裂进行升序排列sort ( A , dim ) ;dim = 1 时 等效于sort ( A ) ;dim = 2 时 表示对A的各列进行升序排列若欲爆裂排列前的索引，则可用[sA,index] = sort ( A , ‘decend’ ) ;A = [ 2 , 1 , 3 , 8 ]sA = [ 8 , 3 , 2 , 1 ]index = [ 4 , 3 , 1 , 2 ] 定义函数function [输出变量] = 函数名称（输入变量）函数的中间部分都是函数体函数的最后要用end结尾输出变量和输入变量可以有多个，用逗号隔开例如： 12345function [ a , b , c ] = test ( d , e , f ) a = d + e ;b = e + f ; c = f + d ; end zeros, ones函数zeros ( 3 ) ; 1234ans = 0 0 0 0 0 0 0 0 0 zeros ( 3 , 1 ) ; 1234ans = 0 00 ones同理","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"},{"name":"Matlab","slug":"Matlab","permalink":"http://1152396492.github.io/tags/Matlab/"}]},{"title":"TOPSIS法","slug":"TOPSIS法","date":"2021-09-22T14:32:59.000Z","updated":"2021-12-25T08:27:11.162Z","comments":true,"path":"2021/09/22/TOPSIS法/","link":"","permalink":"http://1152396492.github.io/2021/09/22/TOPSIS%E6%B3%95/","excerpt":"TOPSIS法(Technique for Order Preference by Similarity to Ideal Solution)可翻译为逼近理想解排序法，也称优劣解距离法TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距","text":"TOPSIS法(Technique for Order Preference by Similarity to Ideal Solution)可翻译为逼近理想解排序法，也称优劣解距离法TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距 层次分析法的局限性1） 决策层不能太多，太多n会很大，潘多矩阵和一致矩阵差距大2）对于已知的指标数据，我们如何利用数据使之更加准确 一个例子对于如下表格 姓名 成绩 排名 修正后的排名 评分 小明 89 2 3 3/10=0.3 小王 60 4 1 1/10=0.1 小张 74 3 2 2/10=0.2 我 99 1 4 4/10=0.4 对于这种评价系统我们可以发现，只要保证排名不变，那么评分就不会改变 优化的想法我们可以取最高的成绩max = 99最低的成绩min = 60构造计算评分的公式: ( x - min ) / ( max - min )然后对于每一个数据进行归一化处理即可但同时最高分与最低分的评价是一定的，1&amp;0 说明为什么不直接将各自的分数除以100再进行归一化处理，这样对于数据的关联性还更强原因有三点 比较对象一般远大于两个 比较的指标往往不是一个方面的 有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的指标：GDP增速故我们最好使用上述优化的想法 拓展问题：增加指标个数 姓名 成绩 与他人争吵的次数 小明 89 2 小王 60 0 小张 74 1 清风 99 3 成绩是越大越好，这样的指标称为极大型指标（效益型指标）与他人争吵的次数越少越好，这样的指标称为极小型指标（成本型指标） 如果我们直接将这些数据加以利用显然是不合适的，因为指标类型不一样所以我们应当统一指标类型一般我们将所有的指标转化为极大型称为指标正向化（最常用） 姓名 成绩 与他人争吵的次数 正向化后的争吵次数 小明 89 2 1 小王 60 0 3 小张 74 1 2 清风 99 3 0 极小型指标转换为极大型指标的公式：max - x 标准化处理显然成绩的大小与争吵次数的大小不是一个量级上的比较为了消去不同指标量纲的影响，需要对已经正向化的矩阵进行标准化处理图像链接：我们得到了标准化处理后的指标，那么我们怎么去联系这些值呢 如何计算得分我们对于最开始的式子：( x - min ) / ( max - min )我们可以将其变形= ( x - min ) / [ ( max - x ) + ( x - min ) ]可以看作是：x与最小值的距离 / ( x与最大值的距离 + x与最小值的距离 )类比可以得出：图像链接： 上面的一大串公式可以这样理解，我们对于只有一个指标时，我们将这一列的数据找出它的最大值和最小值，对于多个指标，同理，我们先将每一列的最大值和最小值找出来。对于每一个评价对象，我们要找出它与最小值的距离可以看成一个平面直角坐标系，它的值所对应的点距离原点（最小值）的距离长度，也就是他的我们所要找的值对于最大值的寻找也同理 计算出未归一化的得分后我们将其进行归一化处理，就可得到他们的排名了 这下子再回到TOPSIS算法，我们就不难理解它为什么是优劣解距离法了吧 梳理第一步将原始矩阵正向化最常见的四种指标 指标 名称 指标特点 例子 极大型（效益型） 指标越大越好 成绩、GDP增速、企业利润 极小型（成本型） 指标越小越好 费用、坏品率、污染程度 中间型指标 越接近某个值越好 水质量评估ph值 区间型指标 落在某个区间最好 体温、水中植物性营养物量 正向化就是将所有指标类型转化为极大型指标 我们介绍了极小型转化为极大型，那么另外两种指标该如何转换呢 中间型指标{xi}是一组中间型指标序列，且最佳的数值为xbest，那么正向化的公式如下M = max { | xi - xbest | } , xi’ = 1 - | xi - xbest | / M我们可以画图去理解这个公式，也是利用距离去计算，思想大致与极小型相同 区间型指标我们设最佳区间为[a,b]M = max { a - min { xi } , max { xi } - b }xi = 1 - ( a - x ) / M , x &lt; a 1 , a &lt;= x &lt;= b 1 - ( x - b ) / M , x &gt; b思路与中间型指标也是差不多的，画图也可以理解 第二步：正向化矩阵标准化第三步：归一化处理并排名带权重的TOPSIS对于之前我们所用到的TOPSIS我们默认了指标之间的权重为1 ，然而实际情况可能更为复杂有n个要评价的对象，m个评价指标的标准化矩阵可以利用层次分析法给这m个评价指标确定权重，每个指标的权重加起来显然是为1的。我们在计算评价对象与最大值之间的距离是可以直接针对每个j（即每个指标）乘以响应的权重wj再进行开方可能有人就要问了，那你这样加起来的距离显然是要小于之前的距离呀，会对得出正确的结论有影响吗其实是没有影响的我们可以理解为对于我们建立的直角坐标系对于某个轴进行了压缩，压缩后虽然大小改变了，但是并不影响我们得出正确的结论 关于TOPSIS的代码见下一篇博客","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"}]},{"title":"c复习","slug":"c复习","date":"2021-09-19T14:32:11.000Z","updated":"2023-11-14T01:50:35.195Z","comments":true,"path":"2021/09/19/c复习/","link":"","permalink":"http://1152396492.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/","excerpt":"这篇文章是大一刚开学对c的复习，十分的不全面，看看就行。","text":"这篇文章是大一刚开学对c的复习，十分的不全面，看看就行。 程序设计语言机器语言 汇编语言 高级语言return 0 ; return表示main函数结束，0表示程序在退出时给执行此程序的操作系统返回来一个结果，即返回值。 c程序的构成预处理部分 宏定义：#define指令定义一个宏，#undef指令删除一个宏定义 头文件包含：#include 条件编译语句：#if、#ifdef、#ifndef、#else和#endif指令根据预处理器可以测试的条件来确定是将一段文本块包含到程序还是将其排除在外说明部分 全局变量 常量：#define PI 3.1416926f \\ const float PI 3.1415926 函数声明执行部分 主函数 其他函数标识符由数字、字母和下划线字符构成的一个连续序列，不能有空白字符。区分大小写整型数据的分类基本整型（int）、短整型（short int）和长整型（long int）int 的取值范围-2147483648 与2147483647（2^31-1)、字节数4short (int)的取值范围 -32768 与 32767 之间、字节数2long (int) 主流编译器一般规定其取值范围与基本int类型相同、字节数4C语言还提供了有符号和无符号整数类型若希望表达非负整数，可以定义无符号整型，即在类型符号前面加上修饰符unsigned加上unsigned变成原来的两倍、字节数不变如：unsigned int : 0 ~ 4294967295整型常数的书写形式 十进制形式 八进制形式： 以0开头，如0100、0123、0123456 十六进制形式：以0x开头，如0x100、0x123 整型数据的储存形式：在计算机内部通常采用补码形式储存补码 （ 后面再补充相应知识 ） 浮点数类型C语言把浮点数类型分为float（单精度浮点型）、double（双精度浮点型）和long double （长双精度浮点型）如表所示 类型 字节数 有效位数 取值范围 foat 4 6 -3.4 * 10^38 ~ 3.4 * 10^38 double 8 15 -1.7 * 10^308 ~ 3.4 * 10^308 long double 16 19 -1.2 * 10^4932 ~ 3.4 * 10^4932 浮点数的书写形式 当小数点前后的数是零时，可以省略0，但是小数点不能省略如5.和.5分别表示5.0和0.5 指数形式 ： 如4.5678E2代表4.5678 * 10^2 \\ -5.7e-3代表-5.7 * 10^-3 （E和e本质是一样的） 默认情况下，浮点型常数为double型。可以在浮点型常数后面加上F(f)以表示float型；也可以在浮点型常数后面加上L(l）表示long double型 字符类型ASCII 字符集的特征：0～9、26个大写英文字母以及26哥消协的英文字母的编码各自是连续的如：A的编码加上25是Z的编码 char类型来描述单字节编码字符集中的字符类型数据C还提供了[signed] char 和 unsigned char 类型，他们的区别在于：在参加算术运算时，把字符的编码当作有符号整数还是无符号整数来看待 字符型常量的三种书写方式： 以一对单引号括起来的一个字符：’A’&#39;1’ 以字符对应的ASCII码来表示，这时必须用转义序列（以反斜杠开头的一串字符） 八进制：’\\ddd’如’101’为字母A的ASCII码的八进制表示 十六进制：’\\xhh’如’\\x41’为字母A的ASCII码的十六进制表示 特殊的转移序列符号表示 符号 含义 符号 含义 \\a 响铃 \\v 纵向制表 \\b 退格 &#39; 单引号 \\f 换页 &#39;‘ 双引号 \\n 换行 \\ |反斜杠 \\r 回车 \\0 字符串结束 \\t 横向制表 “Please enter &quot;Y&quot; or &quot;N&quot;:当字符串包含双引号”时，双引号应写成：&quot;字符常量表示单个字符，字符串常量可表示多个字符字符常量用’’表示,字符串常量用””表示在储存字符串时，通常在最后一个字符后面储存一个表示字符串结束的标记符号 两个实数相除的结果是双精度实数，两个整数相除的结果是整数 常用运算符的优先级与结合性自行百度 输入输出语句printf ( ) ; scanf ( ) ; getchar ( ) ; putchar ( ) ; puts ( ) ; gets ( ) ; 头文件/#include&lt; &gt; 表示直接去查找系统的源文件/#include” “ 表示先去找用户存放源文件的子目录再去找系统文件如果是自己写的头文件必须用第二种如果头文件不在当前目录中，可以在双引号中写出文件路径(#include “C:\\temp\\file.h” scanf 与 printf特别的，scanf ( “%2d%2d” , &amp; a , &amp; b ) ; 输入的数据可以为1234则a = 12 , b = 34 ；如果scanf ( “a=%d,b=%d\\n” , &amp; a , &amp; b ) ;则用户必须输入a=12,b=34 ;如果是scanf ( “%d * %d” , &amp; a , &amp; b ) ;那么用户输入12，34｜12#34都会得到正确的结果，因为 * 为忽略输入修饰符scanf输入时如果是%c那么空格也会被读入 空语句空语句不做任何事情其作用是用于语法上需要一条语句的地方，而该地方又不需要做任何事情；例如 123456&#123; ... goto end ; ... end : ; &#125; 12int i = 1 , sum = 0 ; for ( ; i &lt;= 100 ; sum += i , i ++ ) ; switch 语句123456switch( &lt;整式表达式&gt; ) &#123; case 常量1: 语句序列1 ; break ; case 常量2: 语句序列2 ; break ; ... default ; &#125; 常量可为1、2、3；’c’、’a’…. case 常量1: 语句序列1 ; break ;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言","slug":"C语言","permalink":"http://1152396492.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"复习资料","slug":"复习资料","permalink":"http://1152396492.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"}]},{"title":"层次分析法","slug":"层次分析法","date":"2021-09-18T15:40:58.000Z","updated":"2021-12-25T08:27:38.481Z","comments":true,"path":"2021/09/18/层次分析法/","link":"","permalink":"http://1152396492.github.io/2021/09/18/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/","excerpt":"态度可以转变，生活却不可逆转。-学层次分析法有感 此文章用于记录我学习数学建模的十大模型中层次分析法的学习笔记与自己的理解，本文大多数是由清风老师的数学建模的指导归纳总结得到的，以备今后的数学建模。如果遇到了类似的题目可以尽快的找到相应的模型进行解决。如果本文能帮助到其他阅读到此文章的同志，我也是不胜荣幸。如果文章有所纰漏，也欢迎大家指出。","text":"态度可以转变，生活却不可逆转。-学层次分析法有感 此文章用于记录我学习数学建模的十大模型中层次分析法的学习笔记与自己的理解，本文大多数是由清风老师的数学建模的指导归纳总结得到的，以备今后的数学建模。如果遇到了类似的题目可以尽快的找到相应的模型进行解决。如果本文能帮助到其他阅读到此文章的同志，我也是不胜荣幸。如果文章有所纰漏，也欢迎大家指出。 用途：解决评价性问题层次分析法主要用于解决评价性问题，比如问你，选择哪种方案最好，哪个人或事物更为优秀。需要注意的是，这种问题不包括已经给出具体数据的问题，更多的是比较模糊、较为主观的问题。你需要根据自己的生活经历，网络上搜集的评价资料和结合背景材料去得到相关的评价指标。值得注意的是，我们可以在例如知网等比较权威的网站上去查找相关的论文资料并加以引用，可以让你的文章显得更为专业且结合其他人的观点可以让你的文章更为全面。 评判标准那么评价类问题怎么去评判呢，我们使用打分来解决，根据权重表格计算得分 指标与方案 指标权重 方案1 方案2 ….. 指标1 … … … … 指标2 … … … … ….. … … … … 我们不妨定义 $a_{i j}&amp; 表示为第i行第j列的元素显然针对每个因素所占的权重必定和为1，指标权重的和为1即 $a_{1-n 1}$ 之和为1对于每个指标k, $a_{k 2-n}$ 的和同样为1.而我们评判每个方案时，是不是就可以通过计算指标权重 $\\times$ 方案对应指标的值。通过比较每个方案所对应的结果，我们就可以得知最佳的方案是什么了。 重要程度表 标度 含义 1 A对于B同样重要 3 A对于B稍微重要 5 A对于B明显重要 7 A对于B强烈重要 9 A对于B极端重要 2,4,6,8 两个相邻判断的中值 其中，1/3表示B对于A稍微重要，以此类推 制作判断指标权重的表格通过以上的重要程度表，我们可以根据专家（自己）的判断，制定一份这样的表格 指标 景色 花费 居住 饮食 交通 景色 1 1/2 4 3 3 花费 2 1 7 5 5 居住 1/4 1/7 1 1/2 1/3 饮食 1/3 1/5 2 1 1 交通 1/3 1/5 3 1 1 $a_{i j}$ 表示与j指标相比，i的重要程度$a_{i j}$ &gt;0且 $a_{i j}$ * $a_{j i}$ = 1 称之为正互反矩阵。此矩阵为判断矩阵 一致矩阵由于 $a_{i j}$ = i的重要程度/j的重要程度我们可以知道 $a_{i j}$ * $a_{j k}$ = $a_{i k}$ ，列出数学计算公式即可得到而满足上述关系的矩阵我们称之为一致矩阵一致矩阵有一个特点，各行或者各列之间成倍数关系，利用这个我们可以直接得出这个矩阵是不是一致矩阵 最大特征值由于本人大一，太菜，没有学过线性代数，我只能复制清风老师上课给的一个性质。这个最大特征值你可以不用了解它究竟是个啥，怎么去计算，matlab上面有它的计算函数我们目前只需要知道对于特征值λ：n阶正互反矩阵A为一致矩阵时当且仅当最大特征值λmax=n否则λmax必定大于n 一致性检验步骤： 计算一致性指标CI = （ λmax - n ) / ( n - 1 ) 查找对应的平均随机一致性指标RI 阶数 RI 1 0 2 0 3 0.52 4 0.89 5 1.12 6 1.26 7 1.36 8 1.41 9 1.46 10 1.49 11 1.52 12 1.54 13 1.56 14 1.58 15 1.59 计算一致性比例CR=CI/RI如果CR&lt;0.1则一致性检验可以接受，否则需要修正什么，你问我怎么去修正？你是专家，肯定你来修正啊。计算一致矩阵的权重直接对第一列进行归一化处理，因为第一列与其他列都是成比例的，直接对第一列进行归一化处理是等于其他列对归一化处理：比如说对于如下矩阵 PD|A|BA|1|2B|1/2|1 我们直接计算A：1/（1+1/2） B：（1/2）/（1+1/2）即可 计算判断矩阵的权重我们不妨先假设矩阵A=a11 a12 …. a1na21 a22 …. a2n… … …. …an1 an2 …. ann 算术平均法求权重 分别对每一列进行归一化处理 把每一行的数据分别加起来 把2得到的数据除以n这种方法称之为算术平均法求权重那么算术平均法求得得权重向量wi","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"层次分析法","slug":"层次分析法","permalink":"http://1152396492.github.io/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"}]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"书评","slug":"书评","permalink":"http://1152396492.github.io/tags/%E4%B9%A6%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/tags/%E6%9D%82/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"C语言","slug":"C语言","permalink":"http://1152396492.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://1152396492.github.io/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://1152396492.github.io/tags/Tarjan/"},{"name":"LCA","slug":"LCA","permalink":"http://1152396492.github.io/tags/LCA/"},{"name":"线段树","slug":"线段树","permalink":"http://1152396492.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://1152396492.github.io/tags/Dijkstra/"},{"name":"诗","slug":"诗","permalink":"http://1152396492.github.io/tags/%E8%AF%97/"},{"name":"结构","slug":"结构","permalink":"http://1152396492.github.io/tags/%E7%BB%93%E6%9E%84/"},{"name":"指针","slug":"指针","permalink":"http://1152396492.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://1152396492.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"插值算法","slug":"插值算法","permalink":"http://1152396492.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"},{"name":"Matlab","slug":"Matlab","permalink":"http://1152396492.github.io/tags/Matlab/"},{"name":"复习资料","slug":"复习资料","permalink":"http://1152396492.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"},{"name":"层次分析法","slug":"层次分析法","permalink":"http://1152396492.github.io/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"}]}