{"meta":{"title":"Amentiraz blog","subtitle":"Never knows best","description":"","author":"Amentiraz","url":"http://1152396492.github.io","root":"/"},"pages":[{"title":"links","date":"2021-09-12T21:14:40.000Z","updated":"2021-12-27T02:58:10.433Z","comments":true,"path":"PY.html","permalink":"http://1152396492.github.io/PY.html","excerpt":"","text":""},{"title":"文件归档","date":"2021-12-27T02:57:15.709Z","updated":"2021-12-27T02:57:15.709Z","comments":true,"path":"archive.html","permalink":"http://1152396492.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"重新使用博客","slug":"重新使用博客","date":"2023-11-11T11:04:36.000Z","updated":"2023-11-11T03:38:27.436Z","comments":true,"path":"2023/11/11/重新使用博客/","link":"","permalink":"http://1152396492.github.io/2023/11/11/%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E5%8D%9A%E5%AE%A2/","excerpt":"对许久不使用这个个人博客的解释和对以后本博客的内容的畅想","text":"对许久不使用这个个人博客的解释和对以后本博客的内容的畅想 过去一年都干了啥","categories":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/categories/%E6%9D%82/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/tags/%E6%9D%82/"}]},{"title":"文件学习笔记","slug":"文件学习笔记","date":"2021-12-28T09:46:28.000Z","updated":"2021-12-29T09:19:24.484Z","comments":true,"path":"2021/12/28/文件学习笔记/","link":"","permalink":"http://1152396492.github.io/2021/12/28/%E6%96%87%E4%BB%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"文件是什么文件是指一组相关数据的有序集合，这个数据集有一个名称叫做文件名。文件可以是自己编制的，也可以是系统已有的。事实上我们已经多次使用了文件，例如源程序文件，目标文件、可执行文件、库文件等。为了将结果保存起来，就需要使用文件。将数据以文件的形式存放在光盘、磁盘等外存储器上，可以达到重复利用、永久保存数据的目的。文件可分为普通文件和设备文件两种。通常吧显示器定义为标准输出文件，一般情况下在屏幕上显示有关信息就是向标准输出文件输出。如前面经常使用的printf、putchar函数就是这类输出。键盘通常被指定标准的输入文件，从键盘上输入意味着以标准输入文件输入数据。scanf、getchar函数就属于这类输入。 文件类型文件可分为ASCII码文件和二进制文件两种。ASCII文件也成为文本文件，这种文件在磁盘中存放时每个字符对应一个字节，用于存放对应的ASCII码。例如数6843的存储形式为：ASCII码：00110110 00111000 00110100 00110011十进制码： 6 8 4 3共占用四个字节。ASCII码文件可在屏幕上按字符显示，例如源程序文件就是ASCII文件，用DOS命令TYPE可显示文件的内容。二进制文件是按二进制编码的方式来存放文件的。例如，数6843的存储形式为：00011010 10111011只占两个字节。二进制文件也可以在屏幕中显示，但内容无法读懂。输入输出字符流的开始和结束只由程序控制而不受物理符号（如回车符）的控制。因此也把这种文件称作流式文件。 文件指针在C语言中用一个指针变量指向一个文件，这个指针被称为文件指针，通过文件指针可以对它所指的文件进行各种操作。存放文件的有关信息被保存在一个结构体变量中，它是由系统定义的，取名为FILE。在编写源程序时不必关心FILE结构的细节。例如： 1FILE * 指针变量标识符 其中FILE必须为大写，该结构中含有文件名、文件状态和文件当前位置等信息。注意：在操作系统中，文件被作为重要的系统资源来看待。因此，当程序需要访问文件时，程序员必须显式地打开某个文件，并在使用后关闭它。程序中所有对文件的操作都通过文件指针来实现。 文件打开操作C语言没有输入输出语句，对文件的读写都是用看库函数来实现的。对文件进行操作时应遵循一下步骤： 打开文件。打开文件是指请求系统为指定文件分配内存缓冲区，建立文件的各种有关信息，文件使用前必须先打开。 读写文件。包括文件的读、写、定位等操作。 关闭文件。确保数据完整写入文件并释放内存缓冲区。 打开文件，实际上是建立文件的各种有关信息，并使文件指针指向该文件。关闭文件则是断开指针与文件之间的联系，也就是禁止再对该文件操作。fopen函数用来打开一个文件，其调用的一般形式为： 1文件指针名 = fopen ( 文件名 , 使用文件方式 ) ; 文件指针名必须是被说明为FILE类型的指针变量；文件名使被打开文件的文件名，可以是字符串常量或字符串数组；使用文件方式是指文件类型和操作要求。例如： 12FILE * fp ; fp = ( &quot;file a&quot; , &quot;r&quot; ) ; 其意义使在当前目录下打开文件file a，只允许进行读入操作，并使fp指向该文件。又如： 12FILE * fp ; fp = ( &quot;c:\\\\test&quot; , &quot;rb&quot; ) ; 其意义是打开C驱动磁盘的根目录下的文件test，这是一个二进制文件，只允许按二进制的方式进行读操作。两个反斜杠”\\&quot;第一个表示转义字符，第二个表示根目录。或者使用： 1FILE * fopen ( const char * filename , const char * mode ) ; 返回失败时返回空指针NULL使用文件的方式共有12种，下表给出其符号以及意义。文件使用方式|意义:-:|:-:r|打开文件，只读w|打开或建立文件只写a|追加打开一个文本文件，并在文件末尾写数据rb|二进制文件，同上wb|二进制文件，同上ab|二进制文件，同上r+|读+写w+|读+写a+|读+写rb+&amp;wb+&amp;ab+|类推 总结如下：r(ead) , w(rite) , a(ppend) , t(ext) , b(inary) 。+：读和写查看是否成功读入 1234if ( ( fp = fopen ( &quot;text&quot; , &quot;rb&quot; ) ) == NULL ) &#123; cout &lt;&lt; &quot;error&quot; ; getch ( ) ; exit ( 1 ) ; &#125; 文件关闭操作123FILE * fp ; fp = fopen ( &quot;a.out&quot; , &quot;r&quot; ) ; fclose ( fp ) ; 关闭成功返回值为0，否则为非零值如果打开了多个文件且需要统一关闭： 1int fcloseall ( ) ; 此函数关闭除了标准流意外的所有打开流，刷新所有的流缓冲区，并关闭返回的参数，否则返回EOF。标准流：stdin，stdout，stderr 文件结束检测1int feof ( FLIE * fp ) ; 文件未结束返回0，已结束返回真。 文件错误检测函数1int ferror ( FILE * fp ) ; 发生错误返回非零，否则返回0 定位文件位置指针函数1fseek ( FILE * fp , long offset , int startpos ) ; offset表示目标位置相对起始点的偏移量，要求偏移量为long型数据以便在文件长度大于64KB时不会出错，当用常量表示位移量时，要求加后缀L.startpos表示从何处计算偏移量：SEEK_SET:0 , SEEK_CUR:1 , SEEK_END:2 ;fseek函数一般用于二进制文件，在文本文件中由于要进行转换，故往往会出现错误。 重置文件位置指针函数1rewind ( FILE * fp ) ; 移动到文件开始的位置。无返回值 移动指针到当前位置函数1long ftell ( FILE * p ) ; 若函数调用成功则函数的返回值时当前读写位置偏离文件头部的字节数，否则返回-1 ；文件的长度 12ftell ( fp , 0L , SEEK_END ) ;len = ftell ( fp ) ; 面向字符的文件读写操作1fputc ( int c , FILE * stream ) ; c是带写入的字符，可以是字符常量或者变量。每写入一个字符，文件内部位置指针将向后移动一个字节。返回值为字符或者EOF。如果用写或者读写方式打开一个已存在的文件时将清除原有的文件内容，写入字符从文件首开始，如需保留原有文件内容，必须以追加的方式打开文件。 1ch = fgetc ( FILE * stream ) ; 读取的文件必须是以读写或读的方式打开的。 面向字符串的文件读写操作1char * fgets ( char * string , int n , FILE * stream ) ; 函数的功能是从stream指向的文件中逐一读取n-1个字符，并将读取的字符保存到string指向的连续存储空间。在读取n-1个字符之前如果遇到了换行符或EOF，则读取结束。 1int fputs ( const char * string , FILE * stream ) ; 执行成功返回非负整数，否则返回EOF。不会把\\0写入文件。 面向格式化输入输出的文件读写操作1int fscanf ( FILE * stream , const char * format[,argument]...) ; 返回值为读取正确的数据个数， EOF为读取错误或文件结束。 1int fprintf ( FILE * stream , const char * format[,argument]... ) ; 返回值为正确写入返回数据的个数，负值为读写错误。 面向信息块的文件读写操作12fread ( void * buffer , int size , int count , FILE * fp ) ; fwrite ( void * buffer , int size , int count , FILE * fp ) ; 例如：fread ( fa , 4 , 5 , fp ) ; 的意义是从fp所指的文件中，每次读4个字节，送入实数数组fa中，连续读5次。","categories":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"西电新生赛网络赛题解","slug":"西电新生赛网络赛题解","date":"2021-12-11T10:19:40.000Z","updated":"2021-12-25T08:27:32.117Z","comments":true,"path":"2021/12/11/西电新生赛网络赛题解/","link":"","permalink":"http://1152396492.github.io/2021/12/11/%E8%A5%BF%E7%94%B5%E6%96%B0%E7%94%9F%E8%B5%9B%E7%BD%91%E7%BB%9C%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"持续六天的新生赛终于落下了帷幕，打了8道题，第21名，对于两年没有碰过oi的我来说已经是一个不错的成绩了，如果运气好的话还能水到一等奖，怎么说都血赚。但不得不说的是，我这次的状态比两年前打CSPS要好太多了，如果以我现在的心理素质和之前的知识水平去打，那肯定是不同的结果了。这次比赛原本想用Amentiraz这个昵称去打，但思来想去还是用了最开始的dsfly昵称去打，一来这个名称短（够装B），二来这个名称是我最开始打oi时的昵称，意味着一个新的开始吧。说是六天，实际上就打了前三天，主要是还有本职的学习工作，第二是因为小说太好看了（笑）。还是把除了J题以外的所有题都摸了一遍，可以说除了J题我做不出来，其余的花时间都能做出来，放了H题和K题，H题是因为纯模拟暴力，太恶心了，不想写，K题是让你直接输出时间复杂度，搞了几下没出来，又不想去看资料，于是就放了。（留着时间看番不香吗）","text":"持续六天的新生赛终于落下了帷幕，打了8道题，第21名，对于两年没有碰过oi的我来说已经是一个不错的成绩了，如果运气好的话还能水到一等奖，怎么说都血赚。但不得不说的是，我这次的状态比两年前打CSPS要好太多了，如果以我现在的心理素质和之前的知识水平去打，那肯定是不同的结果了。这次比赛原本想用Amentiraz这个昵称去打，但思来想去还是用了最开始的dsfly昵称去打，一来这个名称短（够装B），二来这个名称是我最开始打oi时的昵称，意味着一个新的开始吧。说是六天，实际上就打了前三天，主要是还有本职的学习工作，第二是因为小说太好看了（笑）。还是把除了J题以外的所有题都摸了一遍，可以说除了J题我做不出来，其余的花时间都能做出来，放了H题和K题，H题是因为纯模拟暴力，太恶心了，不想写，K题是让你直接输出时间复杂度，搞了几下没出来，又不想去看资料，于是就放了。（留着时间看番不香吗） T1位运算题意：输入a，b，输出a&amp;b,a|b,a^b的二进制表示签到题，特判值为0的情况，没啥说的代码： 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std ;void deal ( int x ) &#123; if ( x == 0 ) &#123; cout &lt;&lt; &quot;0&quot; &lt;&lt; endl ; return ; &#125; int a[10000] , len = 1 ; while ( x ) &#123; a[len++] = x &amp; 1 ; x &gt;&gt;= 1 ; &#125; for ( int i = len - 1 ; i &gt;= 1 ; i -- ) cout &lt;&lt; a[i] ; cout &lt;&lt; endl ; return ;&#125;int main ( ) &#123; int a , b ; scanf ( &quot;%d%d&quot; , &amp; a , &amp; b ) ; int ans1 = a &amp; b , ans2 = a | b , ans3 = a ^ b ; deal ( ans1 ) ; deal ( ans2 ) ; deal ( ans3 ) ; return 0 ;&#125; T21931题面：歌颂我们伟大的母校90周年的题目。一眼看不出来，先打表枚举找规律。大胆猜想最佳情况是把每一张劵平摊开，尽可能的覆盖到每一次买套餐，小心求证列几个数学公式就出来了，这题不难。关键是你要眼尖的看出如果不买饭那么就不花钱。 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std ;int main ( ) &#123; int T ; scanf ( &quot;%d&quot; , &amp; T ) ; while ( T -- ) &#123; int n , m ; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; int a[1000] , tot = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) , tot += a[i] ; if ( m &gt; n ) &#123; cout &lt;&lt; tot * 2 * ( m - n ) + tot * n - tot &lt;&lt; endl ; &#125; else if ( m == 0 ) cout &lt;&lt; &quot;0&quot; &lt;&lt; endl ; else cout &lt;&lt; m * tot - tot &lt;&lt; endl ; &#125; return 0 ;&#125; T3等级展示题意：类比于qq的等级，对应星星、月亮、太阳、皇冠有*,(,0,W给出等级，输出图标签到题，简单的一批，直接上代码 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n / 64 ; i ++ ) cout &lt;&lt; &quot;W&quot; ; n %= 64 ; for ( int i = 1 ; i &lt;= n / 16 ; i ++ ) cout &lt;&lt; &quot;O&quot; ; n %= 16 ; for ( int i = 1 ; i &lt;= n / 4 ; i ++ ) cout &lt;&lt; &quot;(&quot; ; n %= 4 ; for ( int i = 1 ; i &lt;= n ; i ++ ) cout &lt;&lt; &quot;*&quot; ; return 0 ; &#125; T4边权之和题意：n个点的无向完全图，对于每个点有点权ai，对于两个点i，j的边权为|ai-aj|，统计边权之和对于998244353取模值考虑把绝对值去掉，先把数组给排序，计算它们的和，如何整体计算即可，也不难。至此，新生赛所有的送分题以及送完了，后面的题或多或少都有些难度，这四道题基本上是所有接触过c的人都能写出来的，只是快慢罢了。我新生赛来迟了30min，我写到这道题时排位30多名，后面排名基本上是只升不降，说明大部分人开始卡住了。 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std ; const long long mod = 998244353 ;long long a[1000006] ;bool cmp ( int x , int y ) &#123; return x &gt; y ; &#125; int main ( ) &#123; int n ; long long ans = 0 , tot = 0 ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%lld&quot; , &amp; a[i] ) ; tot += a[i] ; &#125; sort ( a + 1 , a + 1 + n , cmp ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; tot -= a[i] ; ans += ( ( long long ) ( n - i ) ) * a[i] - tot ; ans %= mod ; &#125; cout &lt;&lt; ans ; return 0 ; &#125; T5tsy的轻音梦（没想到在这都能见到轻音厨，但可惜的是这个轻音厨太坑了）题面：请大家先看看那位交了48次都没过的大佬：怎么说呢，从第一天开始我就仰望大佬的英姿，虽然最后大佬跟我A的题是一个数，但就凭这道题我就不得不佩服他。我一度怀疑他在整活，但看到他在比赛终都没有A掉这题，不由得对他产生崇高的敬意。我开始也被绕进去了，很明显，我们可以联想到幻方，幻方似乎是斜着放，中间是最中间的数，然后呈现一定规律依次放入数，但是我们怎么类比推理都无法得出正确的解法，特别是输出-1给我了很大的迷惑，是不是要考虑奇数次项的奇偶关系？是不是对称放？等等，然而这些都是放屁。想出来正解后我觉得自己是个傻逼。正解：对于奇数次项考虑对角线为分隔除了正中间的一定为偶其余的依次按从大到小的顺序从对角线依次填入，保证左边是偶右边是奇就行。对于偶数次项直接依次填入即可（ls的轻音梦碎了）代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std ; int a[1005][1005] ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; if ( n % 2 == 0 ) &#123; for ( int i = 1 ; i &lt;= n * n ; i ++ ) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; ; if ( i % n == 0 ) cout &lt;&lt; endl ; &#125; &#125; else if ( n == 1 ) cout &lt;&lt; &quot;1&quot; ; else &#123; for ( int i = 1 ; i &lt;= n / 2 ; i ++ ) &#123; a[i][i] = i * 2 ; a[i][i+1] = i * 2 + 1 ; &#125; a[1][3] = 1 ; a[n/2+1][n/2] = n + 1 ; for ( int i = 1 ; i &lt;= n / 2 + 1 ; i ++ ) &#123; int x = n / 2 + i , y = n / 2 + i ; a[x][y] = n + 1 + i * 2 - 1 ; a[x+1][y] = n + 1 + i * 2 ; &#125; int cur1 = n + 1 + ( n / 2 + 1 ) * 2 + 1 ; int cur2 = cur1 - 1 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; for ( int j = 1 ; j &lt;= n ; j ++ ) &#123; if ( ! a[i][j] ) &#123; if ( i &gt; j ) a[i][j] = cur2 , cur2 += 2 ; if ( j &gt; i ) a[i][j] = cur1 , cur1 += 2 ; &#125; cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot; ; &#125; cout &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; T6奇怪的排序题意：这题是很有意思的一道题，考察算法线段树和逆序对，只能说挺难想的吧，难度估计有提高组D2T1的难度。我们发现这个神奇的算法是把每个最大的数抬到第i个位置上并对前i个数排序，第i+1个数按照大小顺序交换到自己的位置上，交换的次数为这个数不重复的逆序对。本身分析到这里我以为套个逆序对就完了，结果发现是不重复的，然后我就弄了一个小暴力，把这些重复的数强制给删掉，结果时间复杂度为O(n^2*logn)比他原来的还大，emmm。对于常见的求逆序对的方法归并和树状数组我都不是很熟悉，于是我就用最无脑的线段树去做，依次判断这个数是否读入过然后决定是否加入到逆序对的计算，最后加起来就行。时间复杂度为O(nlogn)代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ;typedef long long LL ;const int maxn = 200005 ;struct L &#123; int val , add ;&#125; t[maxn&lt;&lt;2] ;int n , m ; LL sum = 0 ;struct M &#123; int val , id ;&#125; a[maxn] ;int vis[maxn] , arank[maxn] ;bool cmp ( M x , M y ) &#123; if ( x.val == y.val ) return x.id &lt; y.id ; return x.val &lt; y.val ;&#125;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) , t[p&lt;&lt;1|1].add += t[p].add ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , int z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ;&#125;int ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; int ans = 0 ; if ( x &lt;= mid ) ans = ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans = ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ;&#125;int main ( ) &#123; scanf ( &quot;%d&quot; , &amp; n ) ; int maxn = 0 , site = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%d&quot; , &amp; a[i].val ) ; if ( a[i].val &gt; maxn ) maxn = a[i].val , site = i ; &#125; for ( int i = 1 ; i &lt;= site ; i ++ ) &#123; if ( a[i].val &gt; a[1].val ) &#123; swap ( a[i].val , a[1].val ) ; sum += 1LL ; &#125; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) a[i].id = i ; sort ( a + 1 , a + 1 + n , cmp ) ; int cur = 2 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; if ( a[i].val == a[i-1].val ) cur -- ; arank[a[i].id] = cur ++ ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; sum += ( LL ) ( ask ( 1 , 1 , n , arank[i] , arank[i] ) ) ; if ( vis[arank[i]] ) continue ; vis[arank[i]] ++ ; change ( 1 , 1 , n , 1 , arank[i] - 1 , 1 ) ; &#125; cout &lt;&lt; sum ; return 0 ;&#125; T7更高更妙的字符游戏题面：对于我来说，博弈论分为两种，一种是简单的，一种是做不出来的。我在比赛中惊喜的发现居然有超过5个人做出来了这道题，我稍加思索，然后大胆假设，也没小心求证，直接交了然后就A了，www。考虑两种必死的情况，也就是之差一个的和不差的，直接判断就行。对于其它情况，我们从上帝视角来看，如果是我发现下一步我可能会输，我们直接把那个字符删了就行，但是万一删了还是必死呢。我们假设有abcabc这种情况，我们肯定不可能删b，删了就死，但我们可以删最边上的a和c啊，那么最终的赢家只由字符串的大小决定 12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ; int main ( ) &#123; int T ; scanf ( &quot;%d&quot; , &amp; T ) ; int flag = 2 ; while ( T -- ) &#123; flag = 2 ; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; char a[1000006] ; a[n+1] = 0 ; scanf ( &quot;%s&quot; , a + 1 ) ; for ( int i = 1 ; i &lt;= n - 1 ; i ++ ) &#123; if ( a[i] == a[i+1] ) flag = 0 ; if ( a[i] == a[i+2] &amp;&amp; i + 2 &lt;= n ) flag = min ( flag , 1 ) ; &#125; if ( flag == 0 ) cout &lt;&lt; &quot;pllj&quot; &lt;&lt; endl ; else if ( flag == 1 ) cout &lt;&lt; &quot;freesin&quot; &lt;&lt; endl ; else &#123; flag = n % 2 ; if ( flag == 0 ) cout &lt;&lt; &quot;pllj&quot; &lt;&lt; endl ; else if ( flag == 1 ) cout &lt;&lt; &quot;freesin&quot; &lt;&lt; endl ; &#125; &#125; return 0 ; &#125; T8内存占用计算纯模拟，利用高精的思想去比较，乘法就先判断位数够不够如果正好就逐位比较，想了思路感觉很恶心没写代码，如果说错了还请谅解。 T9tsy的排序题面： 三年oi一场空，不开long long见祖宗 每个数只出现一次，我们可以计算它们的逆序对，然后就可以算出它们的正序对等等数据，所以我们只需枚举中间两位，答案就是对于每个逆序对，求两个数左边比他们小的和右边比它们大的数的积。但这个算法的复杂度还是O(n^2)，我们把每个数从大到小丢入线段树中，把标号大于它本身的数都加上它的正序对的个数，强制强制把时间复杂度压缩到O(nlogn)，再一次性乘起来就行。注意一定要开longlong 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;using namespace std ; typedef long long LL ; const int maxn = 300005 ; const int mod = 35198030 ; struct L &#123; LL add , val ;&#125; t[maxn&lt;&lt;2] ; int a[maxn] ;struct M &#123; int val , id ;&#125; f[maxn] ; LL g[maxn] ;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) % mod , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1].add %= mod ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) % mod , t[p&lt;&lt;1|1].add += t[p].add ; t[p&lt;&lt;1|1].add %= mod ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; t[p].val %= mod , t[p].add %= mod ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) % mod ;&#125;LL ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val % mod ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; LL ans = 0 ; if ( x &lt;= mid ) ans = ( ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ) % mod ; if ( y &gt; mid ) ans = ( ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) % mod ; return ans ; &#125;int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; f[a[i]].val = ask ( 1 , 1 , n , a[i] , a[i] ) ; f[a[i]].id = i ; change ( 1 , 1 , n , a[i] , n , 1 ) ; &#125; for ( int i = 0 ; i &lt;= ( n &lt;&lt; 2 ) ; i ++ ) t[i].add = t[i].val = 0 ; for ( int i = n ; i &gt;= 1 ; i -- ) &#123; int ind = f[i].id ; g[i] = ( ask ( 1 , 1 , n , ind , ind ) ) % mod ; change ( 1 , 1 , n , ind , n , f[i].val ) ; &#125; LL ans = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; LL num = ( ( n - a[i] ) - ( i - f[a[i]].val - 1 ) ) % mod ; ans = ( ans + ( num * g[a[i]] ) ) % mod ; &#125; cout &lt;&lt; ans ; return 0 ; &#125; T10璀璨星空题意：没去做，也没有想，全场也只有六个做出来了，后面如果它们发题解再补吧。（还得补高数欠下的） T11复杂度理论初步题意：提交了几次没对就没提交了。有几个结论还是可以记下来：对于for循环的时间复杂度就是最内层之积，对于递归就是递归的次数*每次递归的时间复杂度。同样的，有题解再做吧。","categories":[{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"比赛","slug":"比赛","permalink":"http://1152396492.github.io/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"DP","slug":"DP","date":"2021-12-02T17:26:14.000Z","updated":"2023-11-11T03:38:02.341Z","comments":true,"path":"2021/12/03/DP/","link":"","permalink":"http://1152396492.github.io/2021/12/03/DP/","excerpt":"学了三天DP连个P都不会，总的来说就是寄了，每道题不看题解就做不来，试着做了做三道提高组难度的题，做出来了俩，另外一个没有思路。这俩题我都想出了大部分思路，但最后几步由于经验问题没想出来。做完后我以为我懂了，然后膨胀了，去挑战低价购买这道题。然后不出意外寄了。打算先不弄这个了，等以后在弄，先把之前写的贴上来吧。","text":"学了三天DP连个P都不会，总的来说就是寄了，每道题不看题解就做不来，试着做了做三道提高组难度的题，做出来了俩，另外一个没有思路。这俩题我都想出了大部分思路，但最后几步由于经验问题没想出来。做完后我以为我懂了，然后膨胀了，去挑战低价购买这道题。然后不出意外寄了。打算先不弄这个了，等以后在弄，先把之前写的贴上来吧。 珈百璃的堕落这番是好看的，题是不会的。这道题有三个麻烦的点，一个是范围的确定，一个是dp数组的含义确定，还有一个是压缩数组的大小。通过这道题我掌握了基本的DP递推的根据和要领，意思就是我能证明dp递推的正确性了，但然而并没有什么卵用，不会的还是不会。我在高中时就做出来了这道题，但我认为在我高中的时候是不可能想出这道题的思路的，可以说我高中学竞赛就是在自欺欺人了（笑）。但讲道理的是，我起步太慢了，那个时候我也不是什么天才，依葫芦画瓢才是我应该干的，不管怎样我现在是不能这么干了。一个很重要的点是，我们要继承上一个状态，又不能破坏现在的状态，所以起码要二维的数组，我们要尽力压缩空间，注意到第一维只会用到上一个的状态，所以我们调整一下。代码： 123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;cmath&gt;using namespace std ; int tots , totc , dp[2][2000006] ; int T = 1000000 ; char a[2000006] ; int main ( ) &#123; int n ; scanf ( &quot;%d&quot; , &amp; n ) ; int l = 0 , r = 0 ; for ( int i = 0 ; i &lt;= 2000006 ; i ++ ) dp[0][i] = dp[1][i] = -100000006 ; dp[0][T] = 0 ; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; scanf ( &quot;%s&quot; , a ) ; int len = strlen ( a ) , tots = 0 , totc = 0 ; for ( int j = 0 ; j &lt; len ; j += 2 ) a[j] == &#x27;s&#x27; ? tots ++ : totc ++ ; int v = totc , w = tots - totc ; l = min ( l + w , l ) ; r = max ( r + w , r ) ; for ( int j = l ; j &lt;= r ; j ++ ) &#123; dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j] , dp[i&amp;1][T+j] ) ; dp[i&amp;1][T+j] = max ( dp[i&amp;1^1][T+j-w] + v , dp[i&amp;1][T+j] ) ; &#125; &#125; cout &lt;&lt; dp[n&amp;1][T] ; return 0 ; &#125; 垃圾陷阱其实高度和维持生命的时间可以换一下，就是时间做数组，生命做值，但太麻烦了，就没写。要时刻记住当前状态由上一个状态推导而来，别自己吓自己。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ; struct L &#123; int t , f , h ; &#125; trash[1005] ; int dp[105][105] ; bool cmp ( L x , L y ) &#123; return x.t &lt; y.t ; &#125; int main ( ) &#123; int D , G ; scanf ( &quot;%d%d&quot; , &amp; D , &amp; G ) ; for ( int i = 1 ; i &lt;= G ; i ++ ) scanf ( &quot;%d%d%d&quot; , &amp; trash[i].t , &amp; trash[i].f , &amp; trash[i].h ) ; sort ( trash + 1 , trash + 1 + G , cmp ) ; dp[0][0] = 10 ; for ( int i = 1 ; i &lt;= G ; i ++ ) &#123; for ( int j = 0 ; j &lt;= D ; j ++ ) &#123; if ( j &gt;= trash[i].h &amp;&amp; dp[i-1][j-trash[i].h] &gt;= trash[i].t ) &#123; dp[i][j] = max ( dp[i-1][j-trash[i].h] ,dp[i][j] ) ; &#125; if ( dp[i-1][j] &gt;= trash[i].t ) &#123; dp[i][j] = max ( dp[i-1][j] + trash[i].f , dp[i][j] ) ; &#125; &#125; &#125; for ( int i = 1 ; i &lt;= G ; i ++ ) &#123; if ( dp[i][D] != 0 ) &#123; cout &lt;&lt; trash[i].t ; return 0 ; &#125; &#125; int now = 10 ; for ( int i = 1 ; i &lt;= G; i ++ ) &#123; if ( now &lt; trash[i].t - trash[i-1].t ) &#123; cout &lt;&lt; trash[i-1].t + now ; return 0 ; &#125; else now = now - trash[i].t + trash[i-1].t + trash[i].f ; &#125; cout &lt;&lt; trash[G].t + now ; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://1152396492.github.io/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Tarjan","slug":"Tarjan","date":"2021-11-29T16:50:27.000Z","updated":"2021-12-25T08:27:16.300Z","comments":true,"path":"2021/11/30/Tarjan/","link":"","permalink":"http://1152396492.github.io/2021/11/30/Tarjan/","excerpt":"想当年高中组织活动的时候我还专门写过Tarjan的流程和证明，如今已经忘的干干净净，原来的代码也找不到了，只能现写了。总的来说就是利用一个栈，将每个访问到的点push入栈，在寻找的过程中记录两个值，一个是dfn——它是第几个搜索到的，一个是low——它能衍生的点中dfn最小的值。如果一个点dfn==low说明它本身就是最小的点，把它及它栈以上的点全部pop出来就行，因为它上面的点必定是与它形成强联通分量。我们不妨假设它上面的点有不是它强联通分量的，那么此点在回溯到它本身的时候只有两种情况，一是它本身是强联通最小的点，那么在找到此点时会把它上面的点全部pop出去，另一种是它不是最小点，那么在遍历的过程中总会到第一种情况把它排除。Tarjan程序是正确无误的，然后最后要跑一个拓扑，然鹅我不大会。luogu上爆了40pt，然后去看别人的题解秒懂。用拓扑可以优化掉ans、Q、new_val等等数组，估计就80pt了，然后我们还得用dp去解决菊花图这种类型的数据。这道题还给人一个教训是，对于缩点的题，我们记录下每条路径的开始与结束去构造新图，没必要单独列个Q这种数组。40pt代码如下：（其实会个Tarjan就行了吧）","text":"想当年高中组织活动的时候我还专门写过Tarjan的流程和证明，如今已经忘的干干净净，原来的代码也找不到了，只能现写了。总的来说就是利用一个栈，将每个访问到的点push入栈，在寻找的过程中记录两个值，一个是dfn——它是第几个搜索到的，一个是low——它能衍生的点中dfn最小的值。如果一个点dfn==low说明它本身就是最小的点，把它及它栈以上的点全部pop出来就行，因为它上面的点必定是与它形成强联通分量。我们不妨假设它上面的点有不是它强联通分量的，那么此点在回溯到它本身的时候只有两种情况，一是它本身是强联通最小的点，那么在找到此点时会把它上面的点全部pop出去，另一种是它不是最小点，那么在遍历的过程中总会到第一种情况把它排除。Tarjan程序是正确无误的，然后最后要跑一个拓扑，然鹅我不大会。luogu上爆了40pt，然后去看别人的题解秒懂。用拓扑可以优化掉ans、Q、new_val等等数组，估计就80pt了，然后我们还得用dp去解决菊花图这种类型的数据。这道题还给人一个教训是，对于缩点的题，我们记录下每条路径的开始与结束去构造新图，没必要单独列个Q这种数组。40pt代码如下：（其实会个Tarjan就行了吧） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;using namespace std ; const int maxn = 100005 ; int n , m ; int head[maxn] , val[maxn] , nex[maxn] , cnt , to[maxn] , group[10004] ; int tot , ind , a[10004] , stac[10004] , dfn[10004] , vis[10004] , low[10004] ;queue &lt; int &gt; Q[10004] ; int col , in[10004] , new_val[10004] ; int ans[10004] , num ; void add ( int x , int y ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; &#125; void Tarjan ( int u ) &#123; dfn[u] = low[u] = ++ tot ; vis[u] = 1 ; stac[++ind] = u ; for ( int i = head[u] ; i ; i = nex[i] ) &#123; if ( ! dfn[to[i]] ) &#123; Tarjan ( to[i] ) ; low[u] = min ( low[u] , low[to[i]] ) ; &#125; else if ( vis[to[i]] ) &#123; low[u] = min ( low[u] , low[to[i]] ) ; &#125; &#125; if ( low[u] == dfn[u] ) &#123; int v ; col ++ ; while ( v = stac[ind--] ) &#123; Q[col].push ( v ) ; group[v] = col ; vis[v] = 0 ; if ( v == u ) break ; &#125; &#125;&#125;void dfs ( int x , int val ) &#123; int flag = 0 ; for ( int i = head[x] ; i ; i ++ ) &#123; flag = 1 ; dfs ( to[i] , val + new_val[to[i]] ) ; &#125; if ( ! flag ) &#123; ans[++num] = val ; &#125;&#125;void topo ( ) &#123; for ( int i = 1 ; i &lt;= col ; i ++ ) &#123; if ( in[i] == 0 ) &#123; dfs ( i + n , new_val[i] ) ; &#125; &#125;&#125;bool cmp ( int x , int y ) &#123; return x &gt; y ; &#125; int main ( ) &#123; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; while ( m -- ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; add ( x , y ) ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) &#123; if ( ! dfn[i] ) Tarjan ( i ) ; &#125; for ( int i = 1 ; i &lt;= col ; i ++ ) &#123; int new_node = i + n , val = 0 ; while ( ! Q[i].empty ( ) ) &#123; int x = Q[i].front ( ) ; Q[i].pop ( ) ; val += a[x] ; for ( int j = head[x] ; j ; j = nex[j] ) &#123; if ( group[to[j]] == group[x] ) continue ; add ( new_node , group[to[j]] + n ) ; in[to[j]] ++ ; &#125; &#125; new_val[i] = val ; &#125; topo ( ) ; sort ( ans + 1 , ans + 1 + num , cmp ) ; printf ( &quot;%d&quot; , ans[1] ) ; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://1152396492.github.io/tags/Tarjan/"}]},{"title":"LCA","slug":"LCA","date":"2021-11-29T11:20:10.000Z","updated":"2021-12-25T08:29:08.943Z","comments":true,"path":"2021/11/29/LCA/","link":"","permalink":"http://1152396492.github.io/2021/11/29/LCA/","excerpt":"LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 对于一棵树来说，我们为了求它的最近公共祖先其实思路和快速幂是差不多的，我们不能直接一个个的向上查找，这样会使时间复杂度爆表，我们应当以2^k的速率往上找，这样可以使其时间复杂度降为log级别。不得不说luogu上的题解实在是晦涩难懂，我能明白他们在寻找相同深度的点的时候使用log可以更快的找到，但是其实可以一层层的向上跳，可能时间复杂度常数上乘个5左右的数，但影响不大。（还是自己的代码好懂）听说树链剖分也可以做，但这玩意写起来太麻烦了，我高中最快时写一遍也要半个小时（毕竟100多行）总之，我们求LCA时首先找每个节点2^i的父亲，然后先将它们跳到相同的深度然后再同时向上跳，注意特判其中一个节点就是LCA。","text":"LCA（Least Common Ancestors），即最近公共祖先，是指在有根树中，找出某两个结点u和v最近的公共祖先。 ———来自百度百科 对于一棵树来说，我们为了求它的最近公共祖先其实思路和快速幂是差不多的，我们不能直接一个个的向上查找，这样会使时间复杂度爆表，我们应当以2^k的速率往上找，这样可以使其时间复杂度降为log级别。不得不说luogu上的题解实在是晦涩难懂，我能明白他们在寻找相同深度的点的时候使用log可以更快的找到，但是其实可以一层层的向上跳，可能时间复杂度常数上乘个5左右的数，但影响不大。（还是自己的代码好懂）听说树链剖分也可以做，但这玩意写起来太麻烦了，我高中最快时写一遍也要半个小时（毕竟100多行）总之，我们求LCA时首先找每个节点2^i的父亲，然后先将它们跳到相同的深度然后再同时向上跳，注意特判其中一个节点就是LCA。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;using namespace std ;const int maxn = 1000005 ;int n , m , s ;int head[maxn] , to[maxn] , nex[maxn] , cnt = 0 ;int father[maxn][20] , dep[maxn] ;void add ( int x , int y ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; &#125;void dfs ( int x , int fa , int depth ) &#123; father[x][0] = fa ; dep[x] = depth ; for ( int i = 1 ; i &lt;= 19 ; i ++ ) &#123; father[x][i] = father[father[x][i-1]][i-1] ; &#125; for ( int i = head[x] ; i ; i = nex[i] ) &#123; if ( to[i] == fa ) continue ; dfs ( to[i] , x , depth + 1 ) ; &#125;&#125;int LCA ( int x , int y ) &#123; if ( dep[x] &lt; dep[y] ) swap ( x , y ) ; for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123; if ( dep[father[x][i]] &gt;= dep[y] ) &#123; x = father[x][i] ; &#125; &#125; if ( x == y ) return x ; for ( int i = 19 ; i &gt;= 0 ; i -- ) &#123; if ( father[x][i] != father[y][i] ) &#123; x = father[x][i] , y = father[y][i] ; &#125; &#125; return father[x][0] ;&#125;int main ( ) &#123; scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ; for ( int i = 1 ; i &lt; n ; i ++ ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; add ( x , y ) ; add ( y , x ) ; &#125; dfs ( s , 0 , 1 ) ; while ( m -- ) &#123; int x , y ; scanf ( &quot;%d%d&quot; , &amp; x , &amp; y ) ; printf ( &quot;%d\\n&quot; , LCA ( x , y ) ) ; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"LCA","slug":"LCA","permalink":"http://1152396492.github.io/tags/LCA/"}]},{"title":"番剧列表","slug":"番剧列表","date":"2021-11-28T12:57:36.000Z","updated":"2021-12-25T08:27:29.476Z","comments":true,"path":"2021/11/28/番剧列表/","link":"","permalink":"http://1152396492.github.io/2021/11/28/%E7%95%AA%E5%89%A7%E5%88%97%E8%A1%A8/","excerpt":"从我高中开始我入了看番这个巨坑，现在想想也该为这些看过的番做一个汇总并打上我自己心中的分数，算是一个记录吧，这个列表里面仅限于我看了一半以上的番，有些番虽然没看完，但可能是因为某些情节过于尬或者自己不能接受罢了。比如《铃音》是部好作品，但是看到后面实在难以看下去。当然大部分我都是看完了的，有些番我会写一下我自己的看法，同时有些漫画因为不便于再开一个坑去写评价，就一并写在上面了。评价的标准主要看心情，尽量不受网上风气的影响，标准大概是7分B类作品，8分A类，9分S类。首先声明，风评好的番，我看的爽的番和我觉得好的番是三种不同的东西，我尽量结合后两者来评判。","text":"从我高中开始我入了看番这个巨坑，现在想想也该为这些看过的番做一个汇总并打上我自己心中的分数，算是一个记录吧，这个列表里面仅限于我看了一半以上的番，有些番虽然没看完，但可能是因为某些情节过于尬或者自己不能接受罢了。比如《铃音》是部好作品，但是看到后面实在难以看下去。当然大部分我都是看完了的，有些番我会写一下我自己的看法，同时有些漫画因为不便于再开一个坑去写评价，就一并写在上面了。评价的标准主要看心情，尽量不受网上风气的影响，标准大概是7分B类作品，8分A类，9分S类。首先声明，风评好的番，我看的爽的番和我觉得好的番是三种不同的东西，我尽量结合后两者来评判。 番剧 评分 《物语系列》（共13部） 9.0 EVA新世纪福音战士TV+剧场版 8.9 星际牛仔 8.8 RWBY（共7部） 7.8 钢之炼金术师 8.4 FLCL 9.2 三月的狮子 9.5 铃音｜8.3 漂流少年 8.4 青猪 8.2 青春恋爱物语三部 8.2 鬼灭之刃 8.0 辉夜 8.5 超电磁炮共三部 8.3 龙与虎 8.5 雾山五行 8.8 刺客五六七三部 8.8 昨日之歌 8.1 月色真美 8.6 咒术回战 8.7 堀与宫村 8.3 日常 8.8 幸运星 8.8 阴晴不定大哥哥 8.6 转生史莱姆 8.5+7.8 小林家的龙女仆 8.6 转生乙女 8.4 K-ON 8.7 魔女之旅 8.0 永生之酒 8.7 目隐都市 音乐9.0+番7.8 vivy 8.3 美术社 8.6 徒然喜欢你 8.2 无能力者娜娜 8.5 乒乓 9.0 重启咲良田 8.5 女高日常 8.5 男高日常 8.4 神之塔 漫画9.0+动画8.2 游戏人生 8.8 从零开始的异世界生活 第一季8.0+第二季8.8 石纪元 8.0 BEASTARS 8.7 珈百璃的堕落 8.7 恋爱随意链接 7.8 虚构推理 7.8 ReLIFE 8.9 荒川爆笑团 8.6 再见绝望先生 8.7 伪恋两季 8.0 异度侵入 8.5 关公说事 8.4 紫罗兰的永恒花园 8.5+1.0 C&amp;T 8.2 超能力女儿 8.1 天降之物 8.0+0.5 未闻花名 8.3 四谎 8.5 杀戮天使 8.3 樱花庄 7.9 冰菓 8.5 境界的彼方 8.4 野良神三季 8.6","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"http://1152396492.github.io/tags/%E5%8A%A8%E6%BC%AB/"}]},{"title":"线段树","slug":"线段树","date":"2021-11-27T17:12:43.000Z","updated":"2021-12-25T08:27:21.245Z","comments":true,"path":"2021/11/28/线段树/","link":"","permalink":"http://1152396492.github.io/2021/11/28/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"线段树是一种树状数据结构，它可以区间加减，区间乘除等一系列操作，用于处理那种可以合并状态的数据，在使用其3倍左右的空间的代价下使得其修改、查询、求区间和等等操作变得更加快捷。但与此同时，我们无法利用它处理类似于区间最长01序列此类问题，而且线段树代码冗长，其实很容易写错（也可能是因为我太菜了）。我们将一组数据进行如下处理，每相邻的两个数据有一个父亲节点来记录其总的状态，然后再记录其相邻父节点的总的状态，以此类推，最终得到一个树状结构，我们从上到下依次编号1-n，这棵树满足父节点*2=左节点，父节点*2+1=右节点，设每个父节点代表l-r区间的状态，则左区间为l,(r+l)/2 , 右区间为(r+l)/2+1,r。根据此性质我们可以对他们进行维护。每当我们访问一个节点，我们保证此节点的值一定正确，并尽可能少的改变其子孙节点的值，让时间消耗尽可能的小，同时把lazy标记也就是本来应该加的数传递到下一节点。第一颗树实现了区间加与查询，第二颗树实现了区间乘法，加法，判断其中的先后顺序，其实也大同小异。第三颗树用于实现历史最大值这种操作，然而由于本人电脑跑不动500mb的程序，再加之修改起来有点麻烦，就写个大致正确的程序摆在这了。如果要继续完善，那么需要记录次大值并对于spread函数进行修改，就这样吧，后面再来补。","text":"线段树是一种树状数据结构，它可以区间加减，区间乘除等一系列操作，用于处理那种可以合并状态的数据，在使用其3倍左右的空间的代价下使得其修改、查询、求区间和等等操作变得更加快捷。但与此同时，我们无法利用它处理类似于区间最长01序列此类问题，而且线段树代码冗长，其实很容易写错（也可能是因为我太菜了）。我们将一组数据进行如下处理，每相邻的两个数据有一个父亲节点来记录其总的状态，然后再记录其相邻父节点的总的状态，以此类推，最终得到一个树状结构，我们从上到下依次编号1-n，这棵树满足父节点*2=左节点，父节点*2+1=右节点，设每个父节点代表l-r区间的状态，则左区间为l,(r+l)/2 , 右区间为(r+l)/2+1,r。根据此性质我们可以对他们进行维护。每当我们访问一个节点，我们保证此节点的值一定正确，并尽可能少的改变其子孙节点的值，让时间消耗尽可能的小，同时把lazy标记也就是本来应该加的数传递到下一节点。第一颗树实现了区间加与查询，第二颗树实现了区间乘法，加法，判断其中的先后顺序，其实也大同小异。第三颗树用于实现历史最大值这种操作，然而由于本人电脑跑不动500mb的程序，再加之修改起来有点麻烦，就写个大致正确的程序摆在这了。如果要继续完善，那么需要记录次大值并对于spread函数进行修改，就这样吧，后面再来补。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ; typedef long long LL ; const int maxn = 500005 ; struct L &#123; LL val , add ; &#125; t[maxn] ; LL n , m , a[maxn] ; void build ( int p , int l , int r ) &#123; if ( l == r ) &#123; t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; return ; &#125;void spread ( int p , int l , int r ) &#123; if ( t[p].add ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) , t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) , t[p&lt;&lt;1|1].add += t[p].add ; t[p].add = 0 ; &#125;&#125;void change ( int p , int l , int r , int x , int y , int z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val += z * ( r - l + 1 ) ; t[p].add += z ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; &#125;LL ask ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; LL ans = 0 ; if ( x &lt;= mid ) ans = ans + ask ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans = ans + ask ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ; &#125;int main ( ) &#123; scanf ( &quot;%lld%lld&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%lld&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; for ( int i = 1 ; i &lt;= m ; i ++ ) &#123; int com , x , y ; scanf ( &quot;%d%d%d&quot; , &amp; com , &amp; x , &amp; y ) ; if ( com == 1 ) &#123; LL k ; scanf ( &quot;%lld&quot; , &amp; k ) ; change ( 1 , 1 , n , x , y , k ) ; &#125; else printf ( &quot;%lld\\n&quot; , ask ( 1 , 1 , n , x , y ) ) ; &#125; return 0 ; &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std ;const int N = 100003 ;typedef long long ll ;inline int read ( ) &#123; char ch = getchar ( ) ; int res = 0 ; while ( ch &gt; &#x27;9&#x27; || ch &lt; &#x27;0&#x27; ) ch = getchar ( ) ; while ( ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27; ) res = res * 10 + ch - 48 , ch = getchar ( ) ; return res ;&#125;struct L &#123; ll mul , val , add ;&#125; t[N&lt;&lt;2] ;int n , m , a[N] , mod ;void build ( int p , int l , int r ) &#123; t[p].mul = 1 ; if ( l == r ) &#123; t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;void spread ( int p , int l , int r ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; t[p&lt;&lt;1].val = ( t[p&lt;&lt;1].val * t[p].mul + t[p].add * ( mid - l + 1 ) ) % mod ; t[p&lt;&lt;1|1].val = ( t[p&lt;&lt;1|1].val * t[p].mul + t[p].add * ( r - mid ) ) % mod ; t[p&lt;&lt;1].mul = ( t[p&lt;&lt;1].mul * t[p].mul ) % mod ; t[p&lt;&lt;1|1].mul = ( t[p&lt;&lt;1|1].mul * t[p].mul ) % mod ; t[p&lt;&lt;1].add = ( t[p&lt;&lt;1].add * t[p].mul + t[p].add ) % mod ; t[p&lt;&lt;1|1].add = ( t[p&lt;&lt;1|1].add * t[p].mul + t[p].add ) % mod ; t[p].mul = 1 ; t[p].add = 0 ;&#125;void change2 ( int p , int l , int r , int x , int y , ll z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].mul = ( t[p].mul * z ) % mod ; t[p].add = ( t[p].add * z ) % mod ; t[p].val = ( t[p].val * z ) % mod ; return ; &#125; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; if ( x &lt;= mid ) change2 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;void change1 ( int p , int l , int r , int x , int y , ll z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].add = ( t[p].add + z ) % mod ; t[p].val = ( t[p].val + ( r - l + 1 ) * z ) % mod ; return ; &#125; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; if ( x &lt;= mid ) change1 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change1 ( p &lt;&lt; 1 | 1, mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ;&#125;ll aska ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) return t[p].val ; spread ( p , l , r ) ; int mid = ( l + r ) &gt;&gt; 1 ; ll ans = 0 ; if ( x &lt;= mid ) ans += aska ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( mid &lt; y ) ans += aska ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; ans %= mod ; t[p].val = ( t[p&lt;&lt;1|1].val + t[p&lt;&lt;1].val ) % mod ; return ans ;&#125;int main ( ) &#123; n = read ( ) ; m = read ( ) ; mod = read ( ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%d&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; while ( m -- ) &#123; int command = read ( ) ; ll x = read ( ) , y = read ( ) ; if ( command == 1 ) change2 ( 1 , 1 , n , x , y , read ( ) ) ; if ( command == 2 ) change1 ( 1 , 1 , n , x , y , read ( ) ) ; if ( command == 3 ) cout &lt;&lt; aska ( 1 , 1 , n , x , y ) &lt;&lt; endl ; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;queue&gt;using namespace std ; const int maxn = 2000006 ; typedef long long LL ; struct L &#123; LL val , maxa , maxb , add , mina ;&#125; t[maxn] ;LL a[maxn&gt;&gt;2] ; void build ( int p , int l , int r ) &#123; t[p].mina = 0x7fffffff ; if ( l == r ) &#123; t[p].maxa = t[p].maxb = t[p].val = a[l] ; return ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; build ( p &lt;&lt; 1 , l , mid ) ; build ( p &lt;&lt; 1 | 1 , mid + 1 , r ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; t[p].val = t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ; &#125;void spread ( int p , int l , int r ) &#123; int mid = ( l + r ) &gt;&gt; 1 ; //这里有一定的问题，需要判断变为最小的影响，需要分类讨论，其余的没有问题（大概） t[p&lt;&lt;1].val = min ( t[p].mina , ( t[p&lt;&lt;1].val + t[p].add * ( mid - l + 1 ) ) ) ; t[p&lt;&lt;1|1].val = min ( t[p].mina , ( t[p&lt;&lt;1|1].val + t[p].add * ( r - mid ) ) ) ; //持续到这里 t[p&lt;&lt;1].maxa = max ( t[p&lt;&lt;1].maxa + t[p].add , t[p].mina == 0x7fffffff ? 0 : t[p].mina ) ; t[p&lt;&lt;1|1].maxa = max ( t[p&lt;&lt;1|1].maxa + t[p].add , t[p].mina == 0x7fffffff ? 0 : t[p].mina ) ; t[p&lt;&lt;1].maxb = max( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1].maxa ) ; t[p&lt;&lt;1|1].maxb = max ( t[p&lt;&lt;1|1].maxb , t[p&lt;&lt;1|1].maxa ) ; t[p&lt;&lt;1].add += t[p].add ; t[p&lt;&lt;1|1].add += t[p].add ; t[p&lt;&lt;1].mina = min ( t[p&lt;&lt;1].mina , t[p].mina ) ; t[p&lt;&lt;1|1].mina = min ( t[p&lt;&lt;1|1].mina , t[p].mina ) ; t[p].mina = 0x7fffffff ; t[p].add = 0 ; &#125;void change1 ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].maxa += z ; t[p].maxb = max ( t[p].maxb , t[p].maxa ) ; t[p].val = ( t[p].val + z * ( r - l + 1 ) ) ; t[p].add += z ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change1 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change1 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; &#125;void change2 ( int p , int l , int r , int x , int y , LL z ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; t[p].val = min ( t[p].val , z * ( r - l + 1 ) ) ; t[p].maxa = min ( z , t[p].maxa ) ; t[p].mina = z ; t[p].maxb = max ( t[p].maxb , t[p].maxa ) ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; spread ( p , l , r ) ; if ( x &lt;= mid ) change2 ( p &lt;&lt; 1 , l , mid , x , y , z ) ; if ( y &gt; mid ) change2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y , z ) ; t[p].val = ( t[p&lt;&lt;1].val + t[p&lt;&lt;1|1].val ) ; t[p].maxa = max ( t[p&lt;&lt;1].maxa , t[p&lt;&lt;1|1].maxa ) ; t[p].maxb = max ( t[p&lt;&lt;1].maxb , t[p&lt;&lt;1|1].maxb ) ; &#125;LL ask1 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].val ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0 ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans += ask1 ( p &lt;&lt; 1 , l , mid , x , y ) ; if ( y &gt; mid ) ans += ask1 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ; return ans ; &#125;LL ask2 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].maxa ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0x7fffffff ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans = min ( ans , ask2 ( p &lt;&lt; 1 , l , mid , x , y ) ) ; if ( y &gt; mid ) ans = min ( ans , ask2 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) ; return ans ; &#125;LL ask3 ( int p , int l , int r , int x , int y ) &#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) &#123; return t[p].maxb ; &#125; int mid = ( l + r ) &gt;&gt; 1 ; LL ans = 0x7fffffff ; spread ( p , l , r ) ; if ( x &lt;= mid ) ans = min ( ans , ask3 ( p &lt;&lt; 1 , l , mid , x , y ) ) ; if ( y &gt; mid ) ans = min ( ans , ask3 ( p &lt;&lt; 1 | 1 , mid + 1 , r , x , y ) ) ; return ans ; &#125;int main ( ) &#123; int n , m ; scanf ( &quot;%d%d&quot; , &amp; n , &amp; m ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) scanf ( &quot;%lld&quot; , &amp; a[i] ) ; build ( 1 , 1 , n ) ; while ( m -- ) &#123; int op ; scanf ( &quot;%d&quot; , &amp; op ) ; if ( op == 1 ) &#123; int l , r ; LL k ; scanf ( &quot;%d%d%lld&quot; , &amp; l , &amp; r , &amp; k ) ; change1 ( 1 , 1 , n , l , r , k ) ; &#125; else if ( op == 2 ) &#123; int l , r ; LL k ; scanf ( &quot;%d%d%lld&quot; , &amp; l , &amp; r , &amp; k ) ; change2 ( 1 , 1 , n , l , r , k ) ; &#125; else if ( op == 3 ) &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask1 ( 1 , 1 , n , l , r ) ) ; &#125; else if ( op == 4 ) &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask2 ( 1 , 1 , n , l , r ) ) ; &#125; else &#123; int l , r ; scanf ( &quot;%d%d&quot; , &amp; l , &amp; r ) ; printf ( &quot;%lld&quot; , ask3 ( 1 , 1 , n , l , r ) ) ; &#125; &#125; return 0 ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"线段树","slug":"线段树","permalink":"http://1152396492.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"Dijkstra","slug":"Dijkstra","date":"2021-11-27T15:44:01.000Z","updated":"2021-12-25T08:27:14.228Z","comments":true,"path":"2021/11/27/Dijkstra/","link":"","permalink":"http://1152396492.github.io/2021/11/27/Dijkstra/","excerpt":"Dijkstra算法用于解决单源最短路问题，假设起始点为S，在最开始我们可以知道S到某些点的距离，从中取出最小的一个，我们可以保证在我们取出这个最小值的时候不可能有任何路径可以更短的到达此点，，此过程使用了贪心的思想。每当我们找出一个这样的点就更新S到与此点相连的其它点的距离，我们每一次取点都保证取出的是最短的且未被访问的点，这就是Dijkstra算法。","text":"Dijkstra算法用于解决单源最短路问题，假设起始点为S，在最开始我们可以知道S到某些点的距离，从中取出最小的一个，我们可以保证在我们取出这个最小值的时候不可能有任何路径可以更短的到达此点，，此过程使用了贪心的思想。每当我们找出一个这样的点就更新S到与此点相连的其它点的距离，我们每一次取点都保证取出的是最短的且未被访问的点，这就是Dijkstra算法。 网上对于Dijkstra的优缺点有很好的描述我就直接引用了： 优点:O(N*N),加堆优化:O(N*logN)缺点: 在单源最短路径问题的某些实例中，可能存在权为负的边。如果图G＝（V，E）不包含从源s可达的负权回路，则对所有v∈V，最短路径的权定义d(s,v)依然正确，即使它是一个负值也是如此。但如果存在一从s可达的负回路，最短路径的权的定义就不能成立。S到该回路上的结点就不存在最短路径。当有向图中出现负权时，则Dijkstra算法失效。当不存在源s可达的负回路时，我们可用Bellman-Ford算法实现。————————————————版权声明：本文为CSDN博主「Chandery」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/cdy1206473601/article/details/52648619 下面贴上我年轻时写的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std ; const int maxn = 5000000 ;int head[maxn] , nex[maxn] , to[maxn] , val[maxn] , cnt = 0 ; int vis[maxn] , dis[maxn] ; struct L &#123; int val , id ; bool operator &lt; ( const L &amp; x ) const &#123; return val &gt; x.val ; &#125;&#125; ; void add ( int x , int y , int z ) &#123; nex[++cnt] = head[x] ; head[x] = cnt ; to[cnt] = y ; val[cnt] = z ; &#125; void dijkstra ( int s ) &#123; priority_queue &lt; L &gt; Q ; Q.push ( ( L ) &#123; 0 , s &#125; ) ; dis[s] = 0 ; while ( ! Q.empty ( ) ) &#123; L u = Q.top ( ) ; int x = u.id ; Q.pop ( ) ; if ( vis[x] ) continue ; vis[x] = 1 ; for ( int i = head[x] ; i ; i = nex[i] ) &#123; if ( dis[to[i]] &gt; dis[x] + val[i] ) &#123; dis[to[i]] = dis[x] + val[i] ; if ( ! vis[to[i]] ) Q.push ( ( L ) &#123; dis[to[i]] , to[i] &#125; ) ; &#125; &#125; &#125;&#125;int main ( ) &#123; int n , m , s ; scanf ( &quot;%d%d%d&quot; , &amp; n , &amp; m , &amp; s ) ; for ( int i = 1 ; i &lt;= m ; i ++ ) &#123; int x , y , z ; scanf ( &quot;%d%d%d&quot; , &amp; x , &amp; y , &amp; z ) ; add ( x , y , z ) ; &#125; for ( int i = 1 ; i &lt;= n ; i ++ ) dis[i] = 0x7fffffff ; dijkstra ( s ) ; for ( int i = 1 ; i &lt;= n ; i ++ ) printf ( &quot;%d &quot; , dis[i] ) ; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://1152396492.github.io/tags/Dijkstra/"}]},{"title":"算法索引","slug":"算法索引","date":"2021-11-27T09:50:57.000Z","updated":"2021-12-25T08:27:27.013Z","comments":true,"path":"2021/11/27/算法索引/","link":"","permalink":"http://1152396492.github.io/2021/11/27/%E7%AE%97%E6%B3%95%E7%B4%A2%E5%BC%95/","excerpt":"突然之间通知有个acm校赛，我寻思还是得参加一下。时间很紧迫，就先弄个这个总结页，然后慢慢把高中时学过的算法温习一遍，这个工作争取在工作日内完成。此外，以后可能会长期的和acm打交道，算法也会在大二时学习，有什么高级的算法也会在这里呈现。","text":"突然之间通知有个acm校赛，我寻思还是得参加一下。时间很紧迫，就先弄个这个总结页，然后慢慢把高中时学过的算法温习一遍，这个工作争取在工作日内完成。此外，以后可能会长期的和acm打交道，算法也会在大二时学习，有什么高级的算法也会在这里呈现。 字符串KMP字典树 DP,动态规划背包数位DP状压DP区间DP树形DP插头DP优先队列矩阵优化斜率优化单调队列 搜索BFSDFS记忆化搜索剪枝 数论莫比乌斯反演狄利克雷卷积Lucas中国剩余定理拓展欧几里得gcd素数筛逆元 图论图论 树形结构树状数组 博弈论Nim游戏博弈树 线段树线段树主席树 线性结构前缀和栈队列分块st表 平衡树平衡树AVLtreapsplay 二叉堆二叉堆左偏树 基础算法模拟、贪心、递推、递归、暴力略分治 排序我只会sort，其余后面再补 查找算法二分答案 启发式搜索模拟退火A*算法 最短路floyeddijkstrabellman-fordSPFAk短路 生成树PrimKruskal次小生成树 强连通分量Tarjan割点 最大流略 树LCA并查集树剖Link-Cut Tree 线性代数略，下学期学 其它高精","categories":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"索引","slug":"索引","permalink":"http://1152396492.github.io/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"平时抽风写的诗","slug":"平时抽风写的诗","date":"2021-11-26T21:43:09.000Z","updated":"2022-01-08T11:43:16.313Z","comments":true,"path":"2021/11/27/平时抽风写的诗/","link":"","permalink":"http://1152396492.github.io/2021/11/27/%E5%B9%B3%E6%97%B6%E6%8A%BD%E9%A3%8E%E5%86%99%E7%9A%84%E8%AF%97/","excerpt":"这些诗也不是有意写出来的，有些时候情绪到了，突然之间有感觉了，也就写出来了。虽然我知道写的很烂，因为毕竟我即没有大量的阅读现代诗，也没有经过专门的写作训练，但情绪对了，不也达到了目的嘛","text":"这些诗也不是有意写出来的，有些时候情绪到了，突然之间有感觉了，也就写出来了。虽然我知道写的很烂，因为毕竟我即没有大量的阅读现代诗，也没有经过专门的写作训练，但情绪对了，不也达到了目的嘛 细雨朦胧的上午回寝室的路上耳机里传来的是回忆是过去的情绪 不断跳过又不舍删去的歌如今也能静静凝听这意味着成长也意味着失去 《梦》没有任何犹豫把朋友抛下只因望见她的身影 “原来你和我在同一座城市”对于她撒谎这件事心中委屈却毫无芥蒂 明知道她在微笑可为什么我怎么也看不清她的脸 恍惚中猛一转头无论梦里梦外人群里早已不见她的身影 在我初识算法时我一直认为人生不过是动态规划走好每一步即可可最后我发现人生是有后效性的它是无法穷尽的搜索可能我一直都是鼠目寸光吧然而我们永远不会知道我们现在干的事对将来有什么影响我们永远也不会重来自以为对未来的把握很可笑不是吗或许鼠目寸光也不错毕竟我们能享受当下 强者与斗士的区别类似于智者与伟人我更欣赏与羡慕后者因为他们有着无可比拟的信念信念支撑着他们但生活却挫败着他们但这并不重要或许后来斗士不再善战伟人的行为变得愚蠢甚至他们自身的信念也被生活磨砺光滑但是他们的信念传承了下去激励了千千万万的人这是前两者所不能比的 ps：托尼弗格森，我最欣赏的斗士，人民的英雄","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"诗","slug":"诗","permalink":"http://1152396492.github.io/tags/%E8%AF%97/"}]},{"title":"结构","slug":"结构","date":"2021-11-22T21:02:31.000Z","updated":"2021-12-25T08:27:42.556Z","comments":true,"path":"2021/11/23/结构/","link":"","permalink":"http://1152396492.github.io/2021/11/23/%E7%BB%93%E6%9E%84/","excerpt":"结构的基本知识结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在ANSI标准中，自动结构和数组现在也可以进行初始化。","text":"结构的基本知识结构是一个或者多个变量的几何，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。结构可以拷贝、赋值、传递给函数，函数也可以返回结构类型的返回值，在ANSI标准中，自动结构和数组现在也可以进行初始化。 我们首先来看一个关于平面坐标的结构体 123struct point &#123; int x , y ; &#125; ; 关键字struct引入结构声明。结构声明由包含在花括号内的一系列声明组成。关键字struct后面的名字是可选的，称为结构标记（这里是point）。结构标记用于为结构命名，在定义之后，结构标记就代表花括号内的声明，可以用它作为该声明的简写形式。结构中定义的变量称为成员。结构成员，结构标记和普通变量（即非成员）可以采用相同的名字，它们之间不会冲突，因为通过上下文分析总可以对它们进行区分。不同结构中的成员也可以使用相同的名字。struct声明定义了一种数据类型，在标志结构成员表结束的右花括号之后可以跟一个变量表，这与其它基本类型的变量声明是相同的。例如： 1struct &#123; ... &#125; x , y , z ; 从语法角度来说，这种声明与声明 1int x , y , z ; 具有类似的意义。如果结构声明的后面不带变量表，则不需要为它分配存储空间，它仅仅描述了一个结构的模版。但是，如果结构声明中带有标记，那么在以后定义结构实例时便可以使用该标记定义。例如： 1struct point maxpt = &#123; 320 , 200 &#125; ; 定义了一个struct point类型的变量pt。结构的初始化可以在定义的后面使用初值表进行，除指标中同每个成员对应的处置必须是常量表达式。自动结构也可以通过赋值初始化，还可以通过调用返回相应类型结构中的成员。在表达式中可以通过下列形式引用某哥特定结构中的成员：结构名.成员结构可以嵌套，例如 12345struct rect &#123; struct point pt1 ; struct point pt2 ; &#125; ;struct rec screen ; 我们可以使用语句 1screen.pt1.x ; 结构与函数结构的合法操作只有： 作为一个整体赋值 通过&amp;运算符取地址，访问其成员。 其中复制和复制包括向函数传递参数以及从函数返回值。结构之间不可以进行比较。可以用一个常量成员值列表初始化结构，自动结构也可以通过赋值进行初始化。我们可以通过至少3种方法传递结构： 分别传递各个结构成员 传递整个结构 传递指向结构的指针 例如以下函数 123456789101112131415161718struct point makepoint ( int x , int y ) &#123; struct point temp ; temp.x = x ; temp.y = y ; return temp ; &#125;struct rect screen ; struct point middle ; struct point makepoint ( int , int ) ; screen.pt1 = makepoint ( 0 , 0 ) ; screen.pt2 = makepoint ( XMAX , YMAX ) ; middle = makepoint ( ( screen.pt1.x + screen.pt2.x ) &gt;&gt; 1 , ( screen.pt1.y + screen.pt2.y ) &gt;&gt; 1 ) ; struct point addpoint ( struct point p1 , struct point p2 ) &#123; p1.x += p2.x ; p1.y += p2.y ; return p1 ; &#125; addpoint 函数的参数和返回值都是结构类型，结构类型的参数和其它参数是一样的都是通过值传递的。 如果传递给函数的结构很大，使用指针方式的效率通常比赋值整个结构的效率更高，结构指针类似于普通变量指针。声明： 1struct point * pp ; 如果pp指向一个point结构，那么 * pp 即为该结构，而（ * pp ).x 和( * pp ).y则是结构成员。其中( * pp ).x 的圆括号是必须的，因为结构成员运算符”.”的优先级比”*“的优先级高。表达式*pp.x的含义等价于*(pp.x)，因为x不是指针，所以该表达式是非法的。结构指针的使用频率非常高，为了使用方便，C语言提供了另一种简写方式。嘉定p是一个指向结构的指针，可以用p-&gt;结构成员这种形式来引用相应的结构成员。运算符.和-&gt;都是从左至右结合的，所以以下声明都是等价的： 123456struct rec r , * rp = &amp; r ; r.pt1.x rp-&gt;pt1.x (r.pt1).x (rp-&gt;pt1).x 在所有运算符中，下面 4 个运算符的优先级最高：结构运算符“.”和“-&gt;”、用于函数调用的“()”以及用于下标的“[]”，因此，它们同操作数之间的结合也最紧密。例如，对于结构声明 1234struct &#123; int len; char *str; &#125; *p ; 表达式 1++p-&gt;len 将增加 len 的值，而不是增加 p 的值，这是田为，其中的隐含括号关系是++(p-&gt;len)。可 以使用括号改变结合次序。例如：(++p)-&gt;len 将先执行 p 的加 1 操作，再对 len 执行操作； 而(p++)-&gt;len 则先对 len 执行操作，然后再将 p 加 1（该表达式中的括号可以省略）。 同样的道理，*p-&gt;str 读取的是指针 str 所指向的对象的值；*p-&gt;str++先读取指针str 指向的对象的值，然后再将 str 加 1（与*s++相同）；(*p-&gt;str）++将指针 str 指向 的对象的值加 1；*p++-&gt;str 先读取指针 str 指向的对象的值，然后再将 p 加 1。 结构数组考虑编写一个程序，用来统计输入中各个C语言关键字出现的次数。 1234567891011121314151617struct key &#123; char *word; int count;&#125; keytab[] = &#123; &quot;auto&quot;, 0, &quot;break&quot;, 0, &quot;case&quot;, 0, &quot;char&quot;, 0, &quot;const&quot;, 0, &quot;continue&quot;, 0, &quot;default&quot;, 0, /* ... */ &quot;unsigned&quot;, 0, &quot;void&quot;, 0, &quot;volatile&quot;, 0, &quot;while&quot;, 0&#125;; 与结构成员相对应，初值也要按照成对的方式列出。更精确的做法是，将每一行（即每个结构）的初值都括在花括号内，如下所示： 1234&#123; &quot;auto&quot;, 0 &#125;, &#123; &quot;break&quot;, 0 &#125;, &#123; &quot;case&quot;, 0 &#125;, ... 但是，如果初值是简单变量或字符串，并且其中的任何值都不为空，则内层的花括号可以省 略。通常情况下，如果初值存在并且方括号[ ]中没有数值，编译程序将计算数组 keytab 中 的项数。在统计关键字出现次数的程序中，我们首先定义了 keytab。主程序反复调用函数getword 读取输入，每次读取一个单词。每个单词将通过折半查找函数在keytab 中进行查找。注意，关键字列表必须按升序存储在 keytab 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#define MAXWORD 100int getword(char *, int);int binsearch(char *, struct key *, int);/* count C keywords */int main()&#123; int n; char word[MAXWORD]; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((n = binsearch(word, keytab, NKEYS)) &gt;= 0) keytab[n].count++; for (n = 0; n &lt; NKEYS; n++) if (keytab[n].count &gt; 0) printf(&quot;%4d %s\\n&quot;, keytab[n].count, keytab[n].word); return 0;&#125;/* binsearch: find word in tab[0]...tab[n-1] */int binsearch(char *word, struct key tab[], int n)&#123; int cond; int low, high, mid; low = 0; high = n - 1; while (low &lt;= high) &#123; mid = (low+high) / 2; if ((cond = strcmp(word, tab[mid].word)) &lt; 0) high = mid - 1; else if (cond &gt; 0) low = mid + 1; else return mid; &#125; return -1;&#125;int getword ( char * word , int lim ) &#123; int c , getch ( void ) ; void ungetch ( int ) ; char * w = word ; while ( isspace ( c = getch ( ) ) ) ; if ( c != EOF ) * w ++ ; if ( ! isalpha ( c ) ) &#123; * w = &#x27;\\0&#x27; ; return c ; &#125; for ( ; -- lim &gt; 0 ; w ++ ) if ( ! isnum ( * w = getch ( ) ) ) &#123; ungetch ( * w ) ; break ; &#125; * w = &#x27;\\0&#x27; ; return word[0] ; &#125;/*我们可以通过如下方法计算NKEYS的值*/#define NKEYS ( sizeof keytab / sizeof ( struct key ) ) #define NKEYS ( sizeof keytab / sizeof keytab[0] ) getchar函数的返回值也是int类型的 指向结构的指针1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt; #include &lt;ctype.h&gt; #include &lt;string.h&gt; #define MAXWORD 100 int getword(char *, int); struct key *binsearch(char *, struct key *, int); /* count C keywords; pointer version */ int main() &#123; char word[MAXWORD]; struct key *p; while (getword(word, MAXWORD) != EOF) if (isalpha(word[0])) if ((p=binsearch(word, keytab, NKEYS)) != NULL) p-&gt;count++; for (p = keytab; p &lt; keytab + NKEYS; p++) if (p-&gt;count &gt; 0) printf(&quot;%4d %s\\n&quot;, p-&gt;count, p-&gt;word); return 0; &#125; /* binsearch: find word in tab[0]...tab[n-1] */ struct key *binsearch(char *word, struck key *tab, int n) &#123; int cond; struct key *low = &amp;tab[0]; struct key *high = &amp;tab[n]; struct key *mid; while (low &lt; high) &#123; mid = low + (high-low) / 2; if ((cond = strcmp(word, mid-&gt;word)) &lt; 0) high = mid; else if (cond &gt; 0) low = mid + 1; else return mid; &#125; return NULL; &#125; 这一个部分比较简单，就不细写了，上面的程序等于是改写了一下。搜索函数里面的while循环是为了防止死循环写的，当high==low的时候，如果没有low&lt;high这个条件会一直死循环下去。特别需要注意的是千万不要认为结构的长度等于各成员长度的和。因为不同的对象有不同的对齐要 求，所以，结构中可能会出现未命名的“空穴“（hole）。例如，假设 char 类型占用一个字节，int 类型占用 4 个字节，则下列结构： 1234struct &#123; char c; int i; &#125;; 可能需要 8 个字节的存储空间，而不是 5 个字节。使用 sizeof 运算符可以返回正确的对象长度。 自引用结构假定我们需要处理一个更一般化的问题：统计输入中所有单词的出现次数。因为预先不 知道出现的单词列表，所以无法方便地排序，并使用折半查找；也不能分别对输入中的每个单词都执行一次线性查找，看它在前面是否已经出现，这样做，程序的执行将花费太长的时 间。（更准确地说，程序的执行时间是与输入单词数目的二次方成比例的。）我们该如何组织这些数据，才能够有效地处理一系列任意的单词呢？一种解决方法是，在读取输入中任意单词的同时，就将它放置到正确的位置，从而始终 保证所有单词是按顺序排列的。虽然这可以不用通过在线性数组中移动单词来实现，但它仍 然会导致程序执行的时间过长。我们可以使用一种称为二叉树的数据结构来取而代之。 每个不同的单词在树中都是一个节点，每个节点包含： 一个指向该单词内容的指针 一个统计出现次数的计数值 · 一个指向左子树的指针 一个指向右子树的指针任何节点最多拥有两个子树，也可能只有一个子树或一个都没有。 对节点的所有操作要保证，任何节点的左子树只包含按字典序小于该节点中单词的那些单词，右子树只包含按字典序大于该节点中单词的那些单词。要查找一个新单词是否已经在树中，可以从根节点开始，比较新单词与该节点中的单词。若 匹配，则得到肯定的答案。若新单词小于该节点中的单词，则在左子树中继续查找，否则在 右子树中查找。如在搜寻方向上无子树，则说明新单词不在树中，并且，当前的空位置就是 存放新加入单词的正确位置。因为从任意节点出发的查找都要按照同样的方式查找它的一个子树，所以该过程是递归的。相应地，在插入和打印操作中使用递归过程也是很自然的事情。对节点的递归的：","categories":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/tags/c/"},{"name":"结构","slug":"结构","permalink":"http://1152396492.github.io/tags/%E7%BB%93%E6%9E%84/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-11-07T03:13:05.507Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/11/07/hello-world/","link":"","permalink":"http://1152396492.github.io/2021/11/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"指针","slug":"指针","date":"2021-11-04T08:48:35.000Z","updated":"2021-12-25T08:27:24.173Z","comments":true,"path":"2021/11/04/指针/","link":"","permalink":"http://1152396492.github.io/2021/11/04/%E6%8C%87%E9%92%88/","excerpt":"指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。","text":"指针是一种保存变量地址的变量。在存储时，内存被分为一块一块的。每一块都有一个特有的编号。而这个编号可以暂时理解为指针，就像酒店的门牌号一样。 指针与地址一元运算符&amp;可用于取一个对象的地址 1p = &amp; c ; 将把 c 的地址赋值给变量 p，我们称 p 为“指向”c 的指针。地址运算符&amp;只能应用于内存中 的对象，即变量与数组元素。它不能作用于表达式、常量或 register 类型的变量。一元运算符*是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象。下列程序介绍了&amp;与 * 的使用方法 12345int x = 1 , y = 2 , z[10] ; ip = &amp; x ; //表明表达式*ip 的结果是 int 类型。y = * ip ; * ip = 0 ; ip = &amp; z[0] ; 对函数的声明也可以采用这种方式。例如，声明 1double *dp，atof(char *); 表明，在表达式中，*dp 和 atof(s)的值都是 double 类型，且 atof 的参数是一个指向 char类型的指针。指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身。)如果指针 ip 指向整型变量，那么在 x 可以出现的任何上下文中都可以使用 * ip，因此， 语句 1*ip = *ip + 10; 将把ip 的值增加 10。 一元运算符和&amp;的优先级比算术运算符的优先级高，因此，赋值语句 1y = *ip + 1 将把*ip 指向的对象的值取出并加 1，然后再将结果赋值给 y，而下列赋值语句： 1*ip += 1 则将 ip 指向的对象的值加 1，它等同于 1++*ip 或 1(*ip)++ 语句的执行结果。语句( * ip)++中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于*和++这样的一元运算符遵循从右 至左的结合顺序。最后说明一点，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法使用。例如，如果 iq 是另一个指向整型的指针，那么语句 1iq = ip 将把 ip 中的值拷贝到 iq 中，这样，指针 iq 也将指向 ip 指向的对象。 指针与指针参数为了使被调用函数直接修改主调函数中的变量值，我们可以使主调程序将指向所要交换的变量的指针传递给被调用函数，即： 1swap ( &amp; a , &amp; b ) ; 由于一元运算符&amp;用来取变量的地址，这样&amp;a就是一个指向变量a的指针。swap函数的所有参数都声明为指针，并且通过这些指针来间接访问它们所指向的操作数。 123456void swap ( int * px , int * py ) &#123; int temp ; temp = * px ; * px = * py ; * py = temp ; &#125; 指针参数使得被调用函数能够访问和修改主调函数中对象的值。我们来看一个可以接受自由格式输入，并执行转换，并同时返回得到的整数和文件结束标志（EOF）的函数。如果你觉得你已经了解了可以不用看下面的代码，直接进入下一节。 123456789101112131415161718192021int getch ( void ) &#123; return ( bufp &gt; 0 ) ? buf[--bufp] : getchar ( ) ; &#125;void ungetch ( int c ) &#123; if ( bufp &gt;= BUFSIZE ) printf ( &quot;ungetch:too many characters\\n&quot; ) ; else buf[bufp++] = c ; &#125;int getint ( int * pn ) &#123; int c , sign ; while ( isspace ( c = getch ( ) ) ) ; if ( ! isdigit ( c ) &amp;&amp; c != EOF &amp;&amp; c != &#x27;+&#x27; &amp;&amp; c != &#x27;-&#x27; ) &#123; ungetch ( c ) ; return 0 ; &#125; sign = ( c == &#x27;-&#x27; ) ? -1 : 1 ; if ( c == &#x27;+&#x27; || c == &#x27;-&#x27; ) c = getch ( ) ; for ( * pn = 0 ; isdigit ( c ) ; c = getch ( ) ) * pn = 10 * * pn + c - &#x27;0&#x27; ; * pn *= sign ; if ( c != EOF ) ungetch ( c ) ; return c ; &#125; 在getint函数中，*pn始终作为一个普通的整形变量使用。 指针与数组一般来说，用指针编写的程序比用数组下标编写的程序执行速度快，但另一方面，用指针实现的程序理解 起来稍微困难一些。声明 1int a[10]; 定义了一个长度为 10 的数组 a。换句话说，它定义了一个由 10 个对象组成的集合，这 10 个对象存储在相邻的内存区域中，名字分别为 a[0]、a[1]、…、a[9]如果 pa 指向数组中的某个特定元素，那么，根据指针运算的定义，pa+1 将指向下一个元素，pa+i 将指向 pa所指向数组元素之后的第i个元素，而pa-i将指向pa所指向数组元素之前的第 i 个元素。因此，如果指针 pa 指向 a[0]，那么* (pa+1)引用的是数组元素a[1]的内容，pa+i 是数组元素 a[i]的地址，* (pa+i)引用的是数组元素 a[i]的内容无论数组 a 中元素的类型或数组长度是什么，上面的结论都成立。“指针加 1”就意味着，pa+1 指向 pa 所指向的对象的下一个对象。相应地，pa+i 指向 pa 所指向的对象之后的第 i 个对象。对数组元素 a[i]的引用也可以写成*(a+i)这种形式。对第一次接触这种写法的人来说， 可能会觉得很奇怪。在计算数组元素 a[i]的值时，C 语言实际上先将其转换为*(a+i)的形式，然后再进行求值，因此在程序中这两种形式是等价的。如果对这两种等价的表示形式分 别施加地址运算符&amp;，便可以得出这样的结论：&amp;a[i]和 a+i 的含义也是相同的。a+i 是 a之后第 i 个元素的地址。相应地，如果 pa 是个指针，那么，在表达式中也可以在它的后面加 下标。pa[i]与*(pa+i)是等价的。简而言之，一个通过数组和下标实现的表达式可等价地 通过指针和偏移量实现。但是，我们必须记住，数组名和指针之间有一个不同之处，指针是一个变量，因此，在 C语言中，语句 pa=a 和 pa++都是合法的。但数组名不是变量，因此，类似于 a=pa 和 a++形式的语句是非法的。当把数组名传递给一个函数时，实际上传递的是该数组第一个元索的地址。在被调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值 的变量。 123456/*return length of s */int strlen ( char * s ) &#123; int n ; for ( n = 0 ; * s != &#x27;\\0&#x27; ; s ++ ) n ++ ; return n ; &#125; 执行 s++运算不会影响到 strlen 函数的调用者中的字符串，它仅对该指针在 strlen 函数中的私有副本进行自增运算。以下的函数调用均正确： 12345strlen ( &quot;hello world&quot; ) ;char array[100] ; strlen ( array ) ; char * ptr ; strlen ( ptr ) ; 在函数定义中，形式参数 1char s[]; 和 1char *s; 是等价的。我们通常更习惯于使用后一种形式，因为它比前者更直观地表明了该参数是一个指针。如果将数组名传递给函数，函数可以根据情况判定是按照数组处理还是按照指针处理，随后根据相应的方式操作该参数。为了直观且恰当地描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法。也可以将指向子数组起始位置的指针传递给函数，这样，就将数组的一部分传递给了函数。例如，如果 a 是一个数组，那么下面两个函数调用 1f(&amp;a[2]) 与 1f(a+2) 都将把起始于 a[2]的子数组的地址传递给函数 f。在函数 f 中，参数的声明形式可以为 1f(int arr[]) &#123; ... &#125; 或 1f(int *arr) &#123; ... &#125; 对于函数 f 来说，它并不关心所引用的是否只是一个更大数组的部分元素。 如果确信相应的元素存在，也可以通过下标访问数组第一个元素之前的元素。类似于p[-1]、p[-2]这样的表达式在语法上都是合法的，它们分别引用位于 p[0]之前的两个元素。当然，引用数组边界之外的对象是非法的。 地址算术运算下面我们将给出函数alloc和afree，他们分别对标malloc.h头文件中的malloc函数和free函数，只是功能相对于malloc和free更菜而已。这里就先直接贴代码，看不懂也没关系，继续往下看就行 12345678910111213char * alloc ( int n ) &#123; if ( ( allocbuf + ALLOCSIZE - allocp &gt;= n ) ) &#123; allocp += n ; return allocp - n ; &#125; else return 0 ; //C语言保证，0永远不是有效的数据地址，因此返回值0可用来表示发生了异常事件&#125;void afree ( char * p ) &#123; if ( p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE ) allocp = p ; //对指针进行比较&#125; 首先，在某些情况下对指针可以进 行比较运算。例如，如果指针 p 和 q 指向同一个数组的成员，那么它们之间就可以进行类似 于==、!=、&lt;、&gt;=的关系比较运算。如果 p 指向的数组元素的位置在 q 指向的数组元素位置 之前，那么关系表达式p &lt; q的值为真。任何指针与 0进行相等或不等的比较运算都有意义。但是，指向不同数组的元素的指针之间的算术或比较运算没有定义。（这里有一个特例：指针的算术运算中可使用数组最 后一个元素的下一个元素的地址。）其次。我们从前面可以看到，指针可以和整数进行相加或相减运算。例如，结构p + n表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按 4 的倍数来计算。指针的减法运算也是有意义的：如果 p 和 q 指向相同数组中的元索，且 p&lt;q，那么 q-p+1就是位于 p 和 q 指向的元索之间的元素的数目。我们由此可以编写出函数 strlen 的另一个版本，如 12345int strlen ( char * s ) &#123; char * p = s ; while ( * p != &#x27;\\0&#x27; ) p ++ ; return p - s ; &#125; 字符指针与函数字符串常量是一个字符数组，例如： 1&quot;I am a string&quot; 在字符串的内部表示中，字符数组以空字符’\\0’结尾，所以，程序可以通过检查空字符找到 字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大 1。字符串常量最常见的用法也许是作为函数参数，例如： 1princf(&quot;hello, world\\n&quot;&#125;; 当类似于这样的一个字符串出现在程序中时，实际上是通过字符指针访问该字符串的。在上述语句中，printf 接受的是一个指向字符数组第一个字符的指针。也就是说，字符串常量可 通过一个指向其第一个元素的指针访问。除了作为函数参数以外，字符串常量还有其它的用法。例如 12char *pmessage ; pmessage = &quot;now is the time&quot; ; 此操作把一个指向该字符数组的指针赋值给 pmessage。该过程并没有进行字符串的复制，而只 是涉及到指针的操作。C 语言没有提供将整个字符串作为一个整体进行处理的运算符。下面两个定义之间有很大的差别： 12char amessage[] = &quot;nw is the time&quot;; /* 定义一个数组 */ char *pmessage = &quot;now is the time&quot;; /* 定义一个指针 */ 上述声明中，amessage 是一个仅仅足以存放初始化字符串以及空字符’\\0’的一维数组。数组中的单个字符可以进行修改，但 amessage 始终指向同一个存储位置。另一方面，pmessage是一个指针，其初值指向一个字符串常量，之后它可以被修改以指向其它地址，但如果试图 修改字符串的内容，结果是没有定义的掌握了上面的知识，我们现在可以理解下面的程序 1void strcpy ( char * s , char * t ) while ( * s ++ = * t ++ ) ; 1234int strcmp ( char * s , char * t ) &#123; for ( ; * s == * t ; s ++ , t ++ ) if ( * s == &#x27;\\0&#x27; ) return 0 ; return * s - * t ; &#125; 数组指针与指向指针的指针下面是一个运用快速排序来实现字符串排序的程序，qsort部分可自行使用快排实现，我自己想了想也可以用普通的sort + 结构体实现，或许会更好点，这里就不展开了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;stdio.h&gt; #include &lt;string.h&gt; #define MAXLINES 5000 /* max #lines to be sorted */ char *lineptr[MAXLINES]; /* pointers to text lines */ int readlines(char *lineptr[], int nlines); void writelines(char *lineptr[], int nlines); void qsort(char *lineptr[], int left, int right); /* sort input lines */ main() &#123; int nlines; /* number of input lines read */ if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; qsort(lineptr, 0, nlines-1); writelines(lineptr, nlines); return 0; &#125; else &#123; printf(&quot;error: input too big to sort\\n&quot;); return 1; &#125; &#125; #define MAXLEN 1000 /* max length of any input line */ int getline(char *, int); char *alloc(int); /* readlines: read input lines */ int readlines(char *lineptr[], int maxlines) &#123; int len, nlines; char *p, line[MAXLEN]; nlines = 0; while ((len = getline(line, MAXLEN)) &gt; 0) if (nlines &gt;= maxlines || p = alloc(len) == NULL) return -1; else &#123; line[len-1] = &#x27;\\0&#x27;; /* delete newline */ strcpy(p, line); lineptr[nlines++] = p; &#125; return nlines; &#125; /* writelines: write output lines */ void writelines(char *lineptr[], int nlines) &#123; int i; for (i = 0; i &lt; nlines; i++) printf(&quot;%s\\n&quot;, lineptr[i]); &#125;void qsort(char *v[], int left, int right) &#123; int i, last; void swap(char *v[], int i, int j); if (left &gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right)/2); last = left; for (i = left+1; i &lt;= right; i++) if (strcmp(v[i], v[left]) &lt; 0) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last-1); qsort(v, last+1, right); &#125;/* swap: interchange v[i] and v[j] */ void swap(char *v[], int i, int j) &#123; char *temp; temp = v[i]; v[i] = v[j]; v[j] = temp; &#125; 在该例子中，指针数组 lineptr 的声明是新出现的重要概念： 1char *lineptr[MAXLINES]; 它表示 lineptr 是一个具有 MAXLINES 个元素的一维数组，其中数组的每个元素是一个指向字符类型对象的指针。也就是说，lineptr[i]是一个字符指针，而*lineptr[i]是该指针指向的第 i 个文本行的首字符。 由于 lineptr 本身是一个数组名，因此，可按照前面例子中相同的方法将其作为指针使用，这样，writelines 函数可以改写为： 123456/* writelines: write output lines */ void writelines(char *lineptr[], int nlines) &#123; while (nlines-- &gt; 0) printf(&quot;%s\\n&quot;, *lineptr++); &#125; （注意这里的数组变量 lineptr 可以改变值）循环开始执行时，*lineptr 指向第一行，每执行一次自增运算都使得 lineptr 指向下 一行，同时对 nlines 进行自减运算。 多维数组如果将二维数组作为参数传递给函数，那么在函数的参数声明中必须指明数组的列数。数组的行数没有太大关系，因为前面已经讲过，函数调用时传递的是一个指针，它指向由行 向量构成的一维数组，其中每个行向量是具有 13 个整型元素的一维数组。在该例子中，传递 给函数的是一个指向很多对象的指针，其中每个对象是由 13 个整型元素构成的一维数组。因 此，如果将数组 daytab 作为参数传递给函数 f，那么 f 的声明应该写成下列形式： 1f(int daytab[2][13]) &#123; ... &#125; 也可以写成 1f(int daytab[][13]) &#123; ... &#125; 因为数组的行数无关紧要，所以，该声明还可以写成 1f(int (*daytab)[13]) &#123; ... &#125; 这种声明形式表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号[]的优先级高于*的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成 1int *daytab[13] 这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。一般来说，除数组的第一维（下标）可以不指定大小外，其余各维都必须明确指定大小。 指针数组的初始化考虑这样一个问题：编写一个函数 month_name(n)，它返回一个指向第 n 个月名字的 字符串的指针。这是内部 static 类型数组的一种理想的应用。month_name 函数中包含一 个私有的字符串数组，当它被调用时，返回一个指向正确元素的指针。本节将说明如何初始化该名字数组。指针数组的初始化语法和前面所讲的其它类型对象的初始化语法类似： 1234567891011/* month_name: return name of n-th month */ char *month_name(int n) &#123; static char *name[] = &#123; &quot;Illegal month&quot;, &quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; &#125;; return name ; 其中，name 的声明与排序例子中 lineptr 的声明相同，是一个一维数组，数组的元素为字 符指针。name 数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应 位置的元素。第 i 个字符串的所有字符存储在存储器中的某个位置，指向它的指针存储在name[i]中。由于上述声明中没有指明 name 的长度，因此，编译器编译时将对初值个数进 行统计，并将这一准确数字填入数组的长度。 指针与多维数组对于 C 语言的初学者来说，很容易混淆二维数组与指针数组之间的区别，比如上面例子 中的 name。假如有下面两个定义： 12int a[10][20]; int \\*b[10]; 那么，从语法角度讲，a[3][4]和 b[3][4]都是对一个 int 对象的合法引用。但 a 是一个真正的二维数组，它分配了 200 个 int 类型长度的存储空间，并且通过常规的矩阵下标计算公式 20×row+col（其中，row 表示行，col 表示列）计算得到元素 a[row][col]的位置。但是，对 b 来说，该定义仅仅分配了 10 个指针，并且没有对它们初始化，它们的初始化必须以显式的方式进行，比如静态初始化或通过代码初始化。假定 b 的每个元素(其实只取决于最大的）都指向一个具有 20 个元 素的数组，那么编译器就要为它分配 200 个 int 类型长度的存储空间以及 10 个指针的存储空间。指针数组的一个重要优点在于，数组的每一行长度可以不同，也就是说，b 的每个元素不 必都指向一个具有 20 个元素的向量，某些元素可以指向具有 2 个元素的向量，某些元素可以指向具有 50 个元素的向量，而某些元素可以不指向任何向量。 命令行参数编程实际场景中感觉是不常用的，我自己也没看懂，日后补略 指向函数的指针在系统学习完指向含糊的指针后，我发现这玩意就是个纸老虎，只是听起来挺高大上的，其实非常简单。在实际运用中就差不多减少一点代码行数而已，感觉替代性挺强的。（也可能是因为我太菜了）那就开始吧在C语言中，函数本身不是变量，但可以定义指向函数的指针。这种类型的指针可以被赋值、存放在数组中、传递给函数以及作为函数的返回值等等。我们接下来将修改排序函数，在给定可选参数-n的情况下，该函数将按树枝大小而非字典顺序对输入行进行排序。排序程序通常包括3部分：判断任何两个对象之间次序的比较操作、颠倒对象次序的交 换操作、一个用于比较和交换对象直到所有对象都按正确次序排列的排序算法。由于排序算法与比较、交换操作无关，因此，通过在排序算法中调用不同的比较和交换函数，便可以实 现按照不同的标准排序。这就是我们的新版本排序函数所采用的方法。函数 strcmp 按字典顺序比较两个输入行。在这里，我们还需要一个以数值为基础来比较两个输入行，并返回与 strcmp 同样的比较结果的函数 numcmp。这些函 数在 main 之前声明，并且，指向恰当函数的指针将被传递给 qsort 函数。在这里，参数的出错处理并不是问题的重点，我们将主要考虑指向函数的指针问题。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAXLINES 5000 /* max #lines to be sorted */char *lineptr[MAXLINES]; /* pointers to text lines */int readlines(char *lineptr[], int nlines);void writelines(char *lineptr[], int nlines);void qsort(void *lineptr[], int left, int right,int (*comp)(void *, void *));int numcmp(char *, char *);/* sort input lines */int main(int argc, char *argv[])&#123; int nlines; /* number of input lines read */ int numeric = 0; /* 1 if numeric sort */ if (argc &gt; 1 &amp;&amp; strcmp(argv[1], &quot;-n&quot;) == 0) numeric = 1; if ((nlines = readlines(lineptr, MAXLINES)) &gt;= 0) &#123; qsort((void**) lineptr, 0, nlines-1, (int (*)(void*,void*))(numeric ? numcmp : strcmp)); writelines(lineptr, nlines); return 0; &#125; else &#123; printf(&quot;input too big to sort\\n&quot;); return 1; &#125;&#125;/* qsort: sort v[left]...v[right] into increasing order */void qsort(void *v[], int left, int right,int (*comp)(void *, void *))&#123; int i, last; void swap(void *v[], int, int); if (left &gt;= right) /* do nothing if array contains */ return; /* fewer than two elements */ swap(v, left, (left + right)/2); last = left; for (i = left+1; i &lt;= right; i++) if ((*comp)(v[i], v[left]) &lt; 0) swap(v, ++last, i); swap(v, left, last); qsort(v, left, last-1, comp); qsort(v, last+1, right, comp);&#125; 在调用函数qsort的语句中，strcmp和numcmp是函数的地址，因为它们是函数，所以前面不需要加上取地址运算符&amp;，同样的原因，数组名前面也不需要&amp;运算符。改写后的 qsort 函数能够处理任何数据类型，而不仅仅限于字符串。从函数 qsort 的 原型可以看出，它的参数表包括一个指针数组、两个整数和一个有两个指针参数的函数。其中，指针数组参数的类型为通用指针类型 void 。由于任何类型的指针都可以转换为 void类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用 qsort 函数时可以将参数强制转换为 void *类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。 1int ( * comp ) ( void * , void * ) 它表明comp是一个指向函数的指针，该函数具有两个void * 类型的参数，其返回值为int。值得注意的是圆括号是必须的，这样才能保证其中的各个部分正确结合，如果没有括号，如 1int * comp ( void * , void * ) 则表明comp是一个函数，该函数返回一个指向int类型的指针我们在前面讲过函数 strcmp，占用于比较两个字符串。这里介绍的函数 numcmp 也是比 较两个字符串，但它通过调用 atof 计算字符串对应的数值，然后在此基础上进行比较： 1234567891011121314#include &lt;stdlib.h&gt;/* numcmp: compare s1 and s2 numerically */int numcmp(char *s1, char *s2)&#123; double v1, v2; v1 = atof(s1); v2 = atof(s2); if (v1 &lt; v2) return -1; else if (v1 &gt; v2) return 1; else return 0;&#125; 交换两个指引的 swap 函数和本章前面所述的 swap 函数相同，但它的参数声明为 void *类型。 1234567void swap(void * v[], int i, int j;)&#123; void *temp; temp = v[i]; v[i] = v[j]; v[j] = temp;&#125; 链表关于malloc： 函数原型：1extern void \\*malloc(unsigned int num\\_bytes); malloc函数返回值如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。 malloc函数使用注意事项malloc函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。在使用malloc开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。在使用malloc函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;malloc.h&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std ; struct node &#123; int value ; struct node * next ; &#125; ; typedef struct node Node ; //创造节点Node * create_node ( Node * head , int value ) &#123; Node * t_node = ( Node * ) malloc ( sizeof ( Node ) ) ; //千万不可自己去计算数据填入!!! if ( ! t_node ) &#123; printf ( &quot;failed&quot; ) ; exit ( -1 ) ; &#125; t_node -&gt; value = value ; // ( * t_node ).value ; t_node -&gt; next = head ; // return t_node ; &#125;//搜索目标节点Node * search_node ( int val , Node * head ) &#123; for ( Node * p = head ; p ; p = p -&gt; next ) &#123; if ( p -&gt; value == val ) return p ; &#125; return 0 ; &#125;//删除节点，直接越过目标节点进行连接Node * delete_node ( Node * head , int n ) &#123; Node * pre , * cur ; for ( pre = 0 , cur = head ; cur &amp;&amp; cur -&gt; value != n ; pre = cur , cur = cur -&gt; next ) ; if ( ! cur ) return head ; if ( ! pre ) head = head -&gt; next ; else pre -&gt; next = cur -&gt; next ; free ( cur ) ; cur = NULL ; //指向NULL养成好习惯 return head ; &#125;int main ( ) &#123; Node * head = 0 ; while ( 1 ) &#123; int val ; scanf ( &quot;%d&quot; , &amp; val ) ; if ( val == -1 ) break ; head = create_node ( head , val ) ; &#125; int find_val ; scanf ( &quot;%d&quot; , &amp; find_val ) ; Node * goal = search_node ( find_val , head ) ; return 0 ; &#125;","categories":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/categories/c/"}],"tags":[{"name":"指针","slug":"指针","permalink":"http://1152396492.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://1152396492.github.io/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"在云计算中虚拟化与服务模式的特性与应用","slug":"在云计算中虚拟化与服务模式的特性与应用","date":"2021-10-24T20:21:28.000Z","updated":"2021-12-25T08:27:26.065Z","comments":true,"path":"2021/10/25/在云计算中虚拟化与服务模式的特性与应用/","link":"","permalink":"http://1152396492.github.io/2021/10/25/%E5%9C%A8%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%AD%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%8E%E5%BA%94%E7%94%A8/","excerpt":"在云计算中虚拟化与服务模式的特性与应用摘要：云计算是一种基于互联网的计算方式，通过云计算可以将共享的软硬件资源和信息按照需求提供给计算机各种终端和其他设备，使用服务商提供的电脑几件作运算和资源。针对虚拟化阐述它在云计算中的特性和相应的应用。对在云计算中的服务模式分析其中各个层次的特点和在云计算中的应用。","text":"在云计算中虚拟化与服务模式的特性与应用摘要：云计算是一种基于互联网的计算方式，通过云计算可以将共享的软硬件资源和信息按照需求提供给计算机各种终端和其他设备，使用服务商提供的电脑几件作运算和资源。针对虚拟化阐述它在云计算中的特性和相应的应用。对在云计算中的服务模式分析其中各个层次的特点和在云计算中的应用。 1 虚拟化技术过去的人们所使用的计算资源很大程度上依赖于物理机器资源的数量，基于此背景，云计算的出现使得计算资源能够像自来水和电一样按需供应，从根本上颠覆了传统的信息技术。云计算模式最关键的突破就是资源使用方式的改变[1]通过虚拟化的方式何以在几分钟之内，虚拟出一个独立的、随需配置的虚拟机供用户使用。 1.1服务器虚拟化中的特性1.1.1 兼容性服务器的虚拟化是通过在硬件和操作系统之间引入虚拟化层实现硬件与操作系统解耦而实现的。而虚拟化层的主要功能就是实现在一台物理服务器同时运行多个操作系统实例，通过动态分区，虚拟化层使这些操作系统实例可以共享物理服务器资源。[2武志学]虚拟机本质上是一台逻辑上的机器，脱离了硬件的约束使它能够兼容所有标准的x86操作系统、应用和设备驱动程序[3杨青峰] 1.1.2 封装虚拟化的重要功能就是封装，基本原理是通过软件把虚拟机需要的虚拟硬件、操作系统和应用捆绑在一起。这种封装的过程可以增加虚拟机的灵活性，封装后产生的虚拟机可以自由的移动和复制。由于是软硬件一起进行封装，之后就不需要用户重新安装应用，大大提高了计算机部署的效率[3]同时对于用户来说，只需输入激活配置参数，拷贝虚拟机，启动虚拟机、激活虚拟机即可完成部署，降低了部署成本。 1.1.3 分区服务器虚拟化可以通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。将物理服务器虚拟化后，使得一个物理服务器上可以同时运行多个操作系统，每个操作系统单独运行在一台虚机，通过在多个虚机之间划分系统资源以满足使用需求。分区技术何以使得原本会被浪费的硬件资源，通过分区，得到最大化的利用，大大提高了物理计算机的利用效率，同时使得物理硬件的数量与成本降低，提高了生产效率。 1.1.4 隔离封装使的虚拟机共享了一台物理计算机，而隔离是确保这些虚拟机互相隔离，完全独立，互不冲突。隔离技术将硬件划分成多个逻辑上完全隔离的虚拟服务器，再在每个上面各自安装操作系统，部署各自的应用。同时由于虚拟机之间是相互隔离的，一个虚拟机的崩溃或者故障，如操作系统故障，应用程序崩溃，驱动程序故障等等，不会影响同一服务器上的其它虚拟机。也就是说其他的虚拟机仍可以正常使用。 1.1.5 独立于硬件服务器虚拟化提供的封装性和隔离性使大量应用独立运行于各种环境中。管理人员不需频繁根据底层环境调整应用，只需构建一个应用版本并将其发布到虚拟化后的不同类型平台即可。[4] 虚拟化技术给资源使用和调度带来了极大的方便，系统可以根据应用的实际负载情况及时进行资源调度，从而可以保证既不会因为资得不到充分利用造成系统资源的浪费，又能够保证应用和服务不会因为资源缺乏而带来性能的下降。 1.2 Docker容器技术的特性1.2.1 隔离性Docker利用namespace技术来提供隔离的工作空间称之为容器（Container）容器虚拟化技术通过容器为应用程序提供一个隔离的运行空间，这个运行空间将应用程序以及依赖打包为一个标准、独立、轻量的环境，来部署分布式应用，从而满足上述需要比虚拟机更小粒度来控制资源需求。【5】每一个应用只会在Docker创建的命名空间中运行而且不会访问到命名空间之外。同时由于容器之间是相互隔离的，一个容器内的变动不会影响到其他容器 1.2.2 对资源的限制和管理Docker利用Linux提供的cgroup技术对共享资源进行隔离、限制、审计等，让资源得到合理的分配同时保证系统与应用的安全性。cgroup技术限制每个容器的资源数量，使其只使用其必须的资源，同时可以为某一容器设置资源的分配上限来确保系统的安全。当个容器抢占资源时，宿主机根据优先级算法和各进程设定的优先级分配资源【6】。对于云平台来说，可以记录资源的使用量来进行收费，也可以通过观察CPU的使用量来判断某一应用或者容器是否发生死锁，进而对其进行中断或者恢复。 1.2.3 移动性所谓移动性是指，能够通过某种手段比较方便地还原出文中所构建的环境。Docker在LXC基础上进行了进一步封装，引入了AUFS技术，很好的解决了容器的快速移动和更新问题【6】。由此特性，开发者可以使用标准的镜像来构建一套开发容器，将根文件系统设定为只读操作权限，再将一个可写的文件层加载到此系统上。通过AUFS技术，每次对下层可读层的修改只会逻辑存在于上层而不会影响到下层，所以运维人员可以直接把容器部署到运行环境而不需要重新安装。 1.2.4 局限性虽然Docker可以利用cgroup实现资源的限制，但是不能阻止系统占用自己的资源，可能会导致一些需要长期高压的应用无法达到期望。Docker目前还不能分辨具体执行指令的用户，只要一个用户拥有执行Docker的权限，就可以对Docker的容器进行所有的操作，即使该容器不是由该用户创建的。尽管当前的Docker版本已经在安全性方面有了很大的提高，但是相对于虚拟机来讲，安全性问题仍然是Docker容器技术的一个主要弱点。不克服安全性方面的问题，容器技术就不能使用于实际行业应用。【6】由于Docker容器平台是基于Linux内核技术开发的，只能适用于基于Linux系统开发的应用和服务，还不能支持Windows。也就是说，在Windows系统方面，虚拟机仍然是解决应用快速部署的唯一选择。【6基于Docker】 1.3在云计算中虚拟化的应用服务器虚拟化将硬件于操作系统解耦，一台物理服务器可以同时运行多个操作系统，也就是这些操作系统实例可以共享物理服务器资源。通过封装，虚拟机可以自由的移动和复制，降低了部署成本。对于系统来说，系统可以进行资源的调控，从而应用的性能得到长时间的保障。在桌面虚拟化中，用户通过客户端访问服务器上封装的虚拟机，用户体验与现场物理机基本相同，用户客户端现场机的性能不再是用户体验的关键，而是取决于后台虚拟机的配置。【云计算发展战略】此外通过虚拟机封装用户各自的运行环境，有效实现多用户分享数据中心资源。用户利用虚拟化技术，配置私有的服务器，指定所需的CPU数目、内存容量，磁盘空间，实现资源的按需分配。【罗军舟】Docker技术不同于将操作系统与物理主机解耦，它将资源进行了更高级别的抽象，使得资源以更小的尺度来分配和控制，来提高资源的利用率，同时开发者可以将应用解耦，容器将组件更进一步从硬件中分离出来，可以使得应用程序更快的开发与维护。随着Docker容器技术的成熟，容器即服务(Container as a Service,Caas)把第一代云计算的IaaS层与PaaS层合二为一，成为了新一代的云计算架构。【12】Docker进一步步提高资源利用率，还可以缩短资源启动时间，从而为进一步降低公有云服务的成本提供了可能【武志学】。 2服务模式2.1IaaS2.1.1计量计量确保用户能按照他们需要的资源和使用收费。这种计量按照对IaaS服务的评估收费，从实例的启动开始，到实例的终止结束。除了每个实例的基本费用，IaaS提供商还可以对存储、数据传输以及可选的服务(如增强安全性、技术支持或先进监视等)收费。【2003】 2.1.2租赁当你使用IaaS服务，购买服务器和存储资源时，你可以获得你需要的资源即时访问。然而，你不是租赁实际的服务器或其他基础设施。它不像租来一辆卡车开到你的办公室交付服务。该物理组件仍放在基础设施服务提供商的数据中心。【2003】在一个私有的IaaS内，租赁呈现出不同的重点。虽然你可能不会对每个访问资源的用户收费，在该收费模式中，你可以根据各个部门的使用情况，按一星期、一个月或者一年分配使用费用。由于IaaS模型的灵活性，较多资源的使用者应该比较少资源的使用者支付更多的费用。【2003】 2.1.3动态缩放当资源能按照工作负载或任务需求自动伸展或收缩时，这就称为动态缩放。如果用户需求比预期的资源要多，就可以立即获得它们。这种IaaS的提供商或创建者通常优化了环境，这样的硬件、操作系统和自动化可以支持一个巨量的工作负载。【2003】 2.1.4个性化服务通过建立大规模数据中心，IaaS层为上层云计算服务提供海量硬件资源。在虚拟化技术的支持下，IaaS层可以实现硬件资源的按需配置，并提供个性化的基础设施服务。【罗军舟】 2.2PaaS2.2.1 数据存储效率高且安全性高Ghemawat等人为Google设计了GFS（google file system）【226】,在GFS中，一个大文件被划分成若干固定大小的数据块，分布在计算节点的本地硬盘。通过文件的分布式存储，GFS可并行读取文件，提供高I/O吞吐率。【罗军舟】每个数据块都保存有多个副本，由于GFS假设文件具有一次写多次读的特点，可以简化数据块副本与数据的同步问题，同时也保证了文件的安全性。 2.2.2 数据处理简单有效PaaS平台中的数据处理技术基于MapReduce模型，经过一系列的发展已经逐渐走向成熟。在MapReduce模型中，大规模数据处理的难度大大降低。数据同步方面由编程框架自动控制，简化了数据同步的问题。基于DAG优化技术，Dryad可以更加简单高效地处理复杂流程，同时为程序开发者屏蔽了底层的复杂性【罗】 2.2.3 任务容错由于 MapReduce 会监测任务执行状态，重新执行异常状态任务，所以程序员不需考虑任务失败问题。MapReduce的容错机制在检测到异常任务时，会启动该任务的备份任务。备份任务和原任务同时进行，当其中一个任务顺利完成时，调度器立即结束另一个任务。【罗】 2.3SaaS不同的软件及服务应用所开放的功能不同，下面是许多软件及服务应用常见的特征： 2.3.1 配置和定制化软件即服务应用支持类似传统意义上所说的应用“定制化”。换句话说，与传统的企业软件类似，一个单独的客户可以更改配置选项的设置（也称“参数”），这些设置影响它的功能以及界面外观。对于配置选项，每个客户可能拥有他自己的设置（或：参数值）。基于一系列的预定义的配置选项，应用可以被定制化到他所被设计到的程度。 例如：要支持客户的这样一种常见需求——更改一个应用的界面外观以使得这个应用看起来拥有该客户的品牌（或者如果需要，联合品牌），许多软件即服务应用让客户提供（通过一个自助服务界面或通过与应用提供商员工协作）一个客户品牌图标，而有时候是一系列的一贯风格的颜色。然而，除非本来就设计了这么一个选项，否则客户不能更改页面布局。 2.3.2 加速了的特性交付软件即服务应用通常比传统软件更快地被更新[15]，许多情况下是每周或每月一次的频度。这是由几个因素来实现的： 应用被集中式地托管，因此新的发行版本可以直接被放上去而无需要求客户安装新的软件。应用只有一个单独的配置，使得开发测试更快。应用供应商可以访问所有客户数据，加快了设计和回归测试的速度。解决方案提供商能够查看用户在应用中的行为（通常通过网站分析），可以更容易地识别出值得改进的区域。敏捷软件开发方法论进一步使得更快的特性交付成为可能[16]。这个在20世纪90年代中期得到了演进的方法提供了一系列软件开发工具和实践来支持频繁的软件发行版本。 2.3.3 开放式集成协议由于软件即服务应用不能访问一个公司的内部系统（数据库或内部服务），他们绝大多数提供在广域网上操作的集成协议和API。API一般使用HTTP、REST、SOAP和JSON等技术。 软件即服务的无处不在，以及其他因特网服务，还有他们的AP）技术的标准化，造就了混搭的发展——它们是一些轻量级的应用，将来自多个服务的数据、展现和功能结合起来，创建一个复合服务。混搭将软件即服务应用与驻场软件进一步差异化，因为后者无法被在一个公司的防火墙之外被轻易地集成。 2.3.4 协作（和“社交”）功能受到社交网络服务以及其他所谓的Web 2.0功能的启发，许多软件即服务应用提供让他们的用户协作并分享信息的特性。例如，许多在软件即服务模式中交付的项目管理应用提供超出传统项目计划功能的协作特性，让用户可以在任务和计划上进行评注，并在组织内外共享文档。其他一些软件即服务应用允许用户投票和提供新的特性想法。 尽管一些协作相关的功能也被集成进了驻场软件，但不同客户的用户之间的隐性或显性的协作只有在集中式托管的软件上才有可能实现。(SaaS均为维基百科，等到期中考试以后再进行大规模资料查询并作出修改) 3 结束语略 [1] 从容器和 Kubernetes技术看现代云计算的发展轨迹［EB/OL］http://dockone．io/article/140．(ThedevelopmenttrackofmoderncloudcomputingfromcontainerandKubernetes Technology［EB/OL］．［2016-10-16］．http://dockone．io/article/140．) [4]严纪珊。浅谈服务器虚拟化技术(A).科技致富向导。2013，26[10] ROSEN R. Linux Kernel Networking :Implementation and Theoty[M].Berkeley: Apress,2014:405-482.[11] 汪恺，张功萱，周秀敏. 基于容器虚拟化技术研究[J]. 计算机技术与发展，2015（8）： 138⁃141. [百度学术] [Google Scholar]WANG Kai, ZHANG Gongxuan, ZHOU Xiumin. Research on virtualization technology based on container[J]. Computer Technology and Development, 2mnbnbn015（8）： 138⁃141.【12】PIRAGHAJS F, DASTJERDI A V, CALHEIROS R N ,et al .Efficient virtual machine sizing for hosting containers as a service (SERVICES 2015) [C]// Proceedings of the 2015 IEEE World Congress on Services. Piscataway, NJ: IEEE, 2015:31 -38.【2003】华镕.云服务:二、深入探讨IaaS和PaaS[J].中国仪器仪表,2016,(4):61-65.【226】GHEMAWAT S ,GOBIOFF H ,LEUNG S .The Google file system[A]. SOSP03[C]. Bolton Landing, NY ,USA :ACM, 2003.29-43","categories":[{"name":"论文","slug":"论文","permalink":"http://1152396492.github.io/categories/%E8%AE%BA%E6%96%87/"}],"tags":[{"name":"论文","slug":"论文","permalink":"http://1152396492.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"云计算","slug":"云计算","permalink":"http://1152396492.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"小王子书评","slug":"小王子书评","date":"2021-10-10T15:02:22.000Z","updated":"2021-12-25T08:27:19.517Z","comments":true,"path":"2021/10/10/小王子书评/","link":"","permalink":"http://1152396492.github.io/2021/10/10/%E5%B0%8F%E7%8E%8B%E5%AD%90%E4%B9%A6%E8%AF%84/","excerpt":"国庆回家的火车上读完了《小王子》这本书，对于自从高三结束以来一直没有再阅读纸质小说的我来说，这的的确确是一种很新鲜的感觉，让我讶异的发觉，原来阅读是这么一种充实而快乐的体验。当然，打游戏远比此要快乐的多，这也是没办法的事，但以后当我没办法玩手机，也不妨多看看书吧。","text":"国庆回家的火车上读完了《小王子》这本书，对于自从高三结束以来一直没有再阅读纸质小说的我来说，这的的确确是一种很新鲜的感觉，让我讶异的发觉，原来阅读是这么一种充实而快乐的体验。当然，打游戏远比此要快乐的多，这也是没办法的事，但以后当我没办法玩手机，也不妨多看看书吧。 说回正题，《小王子》相比于我之前读的大部分书，都只能称作为侏儒，很难想象一本文字里面穿插了大量图画的书还没有《了不起的盖茨比》厚。两个小时不到，我就读完了它。我读到中间很多场景，都会不禁把书合上，静静的想上一会儿。这本书解决了我很多疑惑，尤其是对于现在的我来说是比较重要的一些问题，那就是如何处理与异性之间的关系，与朋友之间的关系，如何与他人建立亲密关系。《小王子》讲述了一位坠落在沙漠的飞行员，偶遇了来自其它星球的小王子，在与小王子的交谈中，为读者展现了小王子的过往。小王子的过往大致可分为三段，与玫瑰的过往，在星球之间遨游所看到的人与事，在地球上的经历，这里尤其是与狐狸发生的故事。这本书告诉我的一个最深刻的一个道理是：在不成熟的年纪，两情相悦不一定会带来好的结果。而在高三时，我一直以为自己足够成熟，懂得爱与被爱，可惜的是，我以为的成熟，不过仅仅达到了年轻时的小王子。这里的逻辑似乎很奇怪，如果说两个人彼此在乎，不应该主动走向彼此吗，为什么还会分离呢。在书中很生动的把它表现出来了，直接的原因是，我们并不知道对方在想什么。不知道对方在想什么，我们会猜测，对方是怎么看待我们的，我们会困惑，我们对对方做的一切是为了什么。而在这近乎上瘾的痛苦里，我们本能的会为了保护自己，选择逃避。即使我们会后悔。而根本的原因，书中也点出来了，我们太不成熟。就如同书中的玫瑰，为了让小王子心中只有她，明知这样会伤害到小王子，欺骗他说世上只有自己一朵玫瑰，无节制的使唤小王子，不把自己对小王子的爱给表露出来，直到小王子离开，就如同小王子，在悲伤中不理会玫瑰的种种，毅然决然的选择离开。我们不妨想想，是什么促使了小王子离开这个星球。长期的不理解让他们越来越远，以至于无法挽回，即使小王子当时留下来，他们恐怕也很难冰释前嫌，因为他们很难开口。所以小王子要去旅行，他一定要去磨砺自己，他一定要完全的失去玫瑰，他才会懂得珍惜。作者这里借小王子在不同星球穿越，阐发了自己对世界的看法，这里看似好像对整个故事来说可以省略似乎也不会有影响，但它是一个过渡，更是一个调味剂，也是我们所必须经历的一个阶段——我们必须去经历不同的事，见证不同的人，我们才会变得成熟。 未完","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://1152396492.github.io/categories/%E6%9D%82%E8%B0%88/"}],"tags":[{"name":"书评","slug":"书评","permalink":"http://1152396492.github.io/tags/%E4%B9%A6%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"番里面令人印象深刻的台词","slug":"番里面令人印象深刻的台词","date":"2021-10-05T20:53:03.000Z","updated":"2021-12-25T08:27:34.986Z","comments":true,"path":"2021/10/06/番里面令人印象深刻的台词/","link":"","permalink":"http://1152396492.github.io/2021/10/06/%E7%95%AA%E9%87%8C%E9%9D%A2%E4%BB%A4%E4%BA%BA%E5%8D%B0%E8%B1%A1%E6%B7%B1%E5%88%BB%E7%9A%84%E5%8F%B0%E8%AF%8D/","excerpt":"看番对于大多数人来说不过是一种消遣的方式，我也不例外。但我始终觉得，动漫，作为一种信息传播的方式，或多或少都能传达作者的思想，这种思想可能是偏激的，可能是错误的，但一部好的作品，它的思想总会引发人们的共鸣。其实，任何事物，无论它对于别人来说是否有意义，当他对你产生深刻的影响，那么它就是有意义的。对于我来说，在动漫领域目前一共有三部番对我有着重要的意义，分别是《物语系列》、《三月的狮子》、《FLCL》，而类似于《盾娘》等等番剧的台词，我也有很大的感触。这篇文章就是来记录这些的。","text":"看番对于大多数人来说不过是一种消遣的方式，我也不例外。但我始终觉得，动漫，作为一种信息传播的方式，或多或少都能传达作者的思想，这种思想可能是偏激的，可能是错误的，但一部好的作品，它的思想总会引发人们的共鸣。其实，任何事物，无论它对于别人来说是否有意义，当他对你产生深刻的影响，那么它就是有意义的。对于我来说，在动漫领域目前一共有三部番对我有着重要的意义，分别是《物语系列》、《三月的狮子》、《FLCL》，而类似于《盾娘》等等番剧的台词，我也有很大的感触。这篇文章就是来记录这些的。 青春纪行：1.要接受被拒绝的自己是很难的。2.之所以觉得被拒绝，可能是因为你也在拒绝着别人。3.有些话如果当时不说出来的话，不知道为什么，到后面就会越来越难说出口，凡事都直率的说出来，那才是最好的三月的狮子：1.两人肩并肩 仰望星空 如此华美 真的 真的 异常华美 七月的夜空2.一边说着没有战斗的理由 其实我知道我的身体里栖息着野兽即便咬碎撕裂 身边周围所有的东西 为了生存也会横冲直撞的野兽只要战斗开始 无论何时 就会朝着 生存之道伸出手即便会让谁不幸 即便会有未知的世界在等待着自己3.游着 游着 游到了尽头好不容易抵达的岛屿——只要能够一直待在这里 只要不要 抱持着太多希望只要能够接受 停滞不前只要停止思考然后 再一次跃入狂风暴雨的海洋中 朝着下一个岛屿前进的理由对于我而言 似乎已经不存在了3.总有一天 那双眸中所见的景色存在于暴风雨彼端的事物——是的 关于终点的另一侧人们所谈论着的故事我仍然 一无所知4.在穿过这条街道的短短时间里无论置身何处 都仿佛是在梦中游荡 声音变得模糊不清整条街道都是明灭不断的黑白色然后 很久之后我才意识到 那其实只是紧张的缘故在陌生的街道里 我一个人独自生活5.看着他疲惫的侧脸，我想象着他一路是怎么走过来的。没错 我明白了。从一开始暴风雨的对面 就只有更猛烈的狂风暴雨。就算倒下再倒下，也要把飞散的自己的碎片找回来。不管跌倒几次都要站起来，没有止境的彷徨。那为什么要选这条路 答案绝不能去问这张侧脸。答案 只有在狂风暴雨中问自己。6.March comes in like a lion,三月如狮而来，and goes out like a lamb.如羊而去。7.在暴风雨的彼端依旧是暴风雨。8.什么都没做过，还不知道自己的实力，不安的原因就在那里，你不愿意努力是因为你怕知道了自己的水平以后会失望，知道了自己的实力，才能知道自己要做什么。9.今天也要变成火球，要让对手好好痛苦一番才行","categories":[{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"动漫","slug":"动漫","permalink":"http://1152396492.github.io/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"娱乐","slug":"娱乐","permalink":"http://1152396492.github.io/tags/%E5%A8%B1%E4%B9%90/"}]},{"title":"插值算法","slug":"插值算法","date":"2021-10-03T16:21:52.000Z","updated":"2021-12-25T08:27:36.733Z","comments":true,"path":"2021/10/04/插值算法/","link":"","permalink":"http://1152396492.github.io/2021/10/04/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/","excerpt":"插值算法主要运用于在数学建模竞赛中，现有的数据极少，不足以支撑分析的进行，这时候就需要使用一些数学的方法插值的作用，“模拟产生”一些新的但又比较靠谱的值来满足需求","text":"插值算法主要运用于在数学建模竞赛中，现有的数据极少，不足以支撑分析的进行，这时候就需要使用一些数学的方法插值的作用，“模拟产生”一些新的但又比较靠谱的值来满足需求 一维插值问题问题如下：已经有n+1个节点(xi,yi)(i=0,1,…,n),其中xi互不相同，不妨设a &lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b ,求任一插值点x * （不等于xi）处的插值y *思路：构造y=f(x),使得f(x)过所有节点，即可得到y * 插值法的概念设函数y=f(x)在区间[a,b]上有定义，且已知在点a&lt;= x0 &lt; x1 &lt; … &lt; xn &lt;= b 上的值分别为 y0 , y1 , … , yn若存在一简单函数P(x)使P(xi) = yi ( i = 0 , 1 , 2 , … , n )则称P(x)为f(x)的插值函数，点x0,x1,…,xn称为插值节点，包含插值节点的区间[a,b]称为插值区间求插值函数P(x)的方法称为插值法插值法是不唯一的代数多项式：若P(x)是次数不超过n的代数多项式，即P(x) = a0 + a1x + … + anx^n分段插值：若P(x)为分段多项式，就称为分段插值三角插值：若P(x)为三角多项式，就称为三角插值（不予讨论）（一般要用到傅立叶变换等复杂的数学工具）一般来讲三角插值适用于对周期函数的插值（三角函数嘛） 插值法原理定理：设有n+1个互不相同的节点(xi,yi)(i=0,1,2,…,n)则存在唯一的多项式：Ln(x) = a0 + a1x + … + anx^n 使得Ln(xj) = yj (j=0,1,2,…n)证 构造方程组「a0 + a1x0 + … + anx0^n = y0a0 + a1x1 + … + anx1^n = y1…a0 + a1xn + … + anxn^n = yn 」 图片： 拉格朗日插值法在数值分析中，拉格朗日插值法是以法国十八世纪数学家约瑟夫·拉格朗日命名的一种多项式插值方法。如对实践中的某个物理量进行观测，在若干个不同的地方得到相应的观测值，拉格朗日插值法可以找到一个多项式，其恰好在各个观测的点取到观测到的值。这样的多项式称为拉格朗日（插值）多项式。对于两个点:(x0,y0) , (x1,y1)f(x) = ( x - x1 ) y0 / ( x0 - x1 ) + ( x - x0 ) y1 / ( x1 - x0 )对于三个点:(x0,y0),(x1,y1),(x2,y2)f(x) = [ ( x - x1 ) ( x - x2 ) y0 ] / [ ( x0 - x1 ) ( x0 - x2 ) ] [ ( x - x0 ) ( x - x2 ) y1 ] / [ ( x1 - x0 ) ( x1 - x2 ) ] [ ( x - x0 ) ( x - x1 ) y2 ] / [ ( x2 - x0 ) ( x2 - x1 ) ]我们可以归纳发现，这种式子如果取其中的一个xi取得的值必定是yi，因为其它项为0，对应的xi的yi的系数必定为1然而我们实际情况中却不可能用拉格朗日插值法，他有很多问题龙格现象图片1:图片2:这引出了两个问题 插值多项式次数高，精度未必显著提高 插值多项式次数越高，摄入误差可能显著增大我们可以得到，对于高次的多项式插值时，如果我们不确定曲线的类型，我们尽量不要使用那么如何提高插值精度呢采用分段线性插值分段插值分段线性插值如果我们要在中间找一个值，我们找距离它最近的两点，两点之间连一条线段，直接在这条线段上找x对应的y值即可这种插值是十分简单的，也是不精准的分段二次插值分段二次插值也是非常简单的，我们可以寻找距离这个插入点最近的三个点，三个点可以形成一个二次函数，同理可以直接取二次函数的值分段二次插值又称为分段抛物线插值牛顿插值法·","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"插值算法","slug":"插值算法","permalink":"http://1152396492.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"}]},{"title":"TOPSIS-MATLAB","slug":"TOPSIS-MATLAB","date":"2021-09-22T18:35:13.000Z","updated":"2021-12-25T08:27:04.124Z","comments":true,"path":"2021/09/23/TOPSIS-MATLAB/","link":"","permalink":"http://1152396492.github.io/2021/09/23/TOPSIS-MATLAB/","excerpt":"代码如下","text":"代码如下 主函数代码12345678910111213141516171819202122232425262728clear;clcload data_water_quality.mat//正向化[n,m] = size ( X ) ;disp ( [&#x27;共有&#x27;num2str ( n ) &#x27;个评价对象,&#x27;num2str ( m ) &#x27;个评价指标] ) Judge = input ([&#x27;这&#x27;num2str(m)&#x27;个指标是否需要经过正向化处理，需要输入1，不需要输入0:&#x27;]);if Judge == 1 Position = input (&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]:&#x27;) ; disp ( &#x27;请输入需要处理的这些列的指标类型（1:极小型，2:中间型，3:区间型）&#x27;) Type = input (&#x27;例如2极小，3区间，6中间就输入[1,3,2]:&#x27; ) ; for i = 1 : size ( Position , 2 ) X ( : , Position ( i ) ) = Positivization ( X ( : , Position ( i ) ) , Type ( i ) , Position ( i ) ) ; //Positization是我们定义的函数 end disp (&#x27;正向化后的举证X=&#x27; ) disp ( X ) end//对正向化对举证进行标准化Z = X ./ repmat ( sum ( X .* X ) .^ 0.5 , n , 1 ) ;disp ( &#x27;标准化矩阵Z=&#x27; ） disp (Z) //计算最大值与最小值的距离，并算出得分D_P = sum ( [Z - repmat ( max ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; D_N = sum ( [Z - repmat ( min ( Z ) , n , 1 ) .^ 2 ] , 2 ) .^ 0.5 ; S = D_N ./ ( D_P + D_N ) ; disp ( &#x27;最后的得分为：&#x27; ) stand_S = S / sum ( S ) [sorted_S , index] = sort ( stand_S , &#x27;descend&#x27; ) Positivization函数1234567891011121314151617181920212223function [ posit_x ] = Positivization ( x , type , i ) if type == 1 disp([&#x27;第&#x27;num2str ( i ) &#x27;列是极小型，正在正向化&#x27;]) posit_x = Min2Max ( x ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else if type == 2 dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是中间型&#x27;]) best = input (&#x27;请输入最佳的那一个值:&#x27;) ; posit_x = Mid2Max ( x , best ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ; disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else if type == 3 dis ( [&#x27;第&#x27;num2str ( i ) &#x27;列是区间型&#x27;]) a = input (&#x27;请输入区间的下界&#x27;) ; b = input (&#x27;请输入区间的上界&#x27;) ; posit_x = Inter2Max ( x , a , b ) ; disp([&#x27;第&#x27;num2str ( i ) &#x27;列正向化处理完成]) ; disp(&#x27;~~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~~~~~&#x27;) else disp (&#x27;没有这种类型的指标请检查Type向量中是否有除了1、2、3以外的其他值&#x27;) endend Min2Max(x)函数123function [ posit_x ] = Min2Max ( x ) posit_x = max ( x ) - x ; end Mid2Max(x,best)函数1234function [ posit_x ] = Mid2Max ( x , best ) M = max ( abs ( x - best ) ) ; posit_x = 1 - abs ( x - best ) / M ; end Inter2Max(x,a,b)函数12345678910111213function [ posit_x ] = Inter2Max ( x , a , b ) ; M = max ([ a - min ( x ) , max ( x ) - b ] ) ; r_x = size ( x , 1 ) ; posit_x = zeros ( r_x , 1 ) ; for i = 1 : r_x if x(i) &lt; a posit_x(i) = 1 - ( a - x(i) ) / M ; else if x(i) &gt; b posit_x(i) = 1 - ( x(i) - b ) / M ; else posit_x(i) = 1 ; end endend 原始矩阵正向化将Excel内的数据直接粘贴进matlab里，赋值给变量将此变量另存为至与代码相同的目录下调用直接用load xxx.mat sort函数sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排序，sort(A)是默认的升序，而sort(A,’descend’)是降序若A是矩阵，默认对A的割裂进行升序排列sort ( A , dim ) ;dim = 1 时 等效于sort ( A ) ;dim = 2 时 表示对A的各列进行升序排列若欲爆裂排列前的索引，则可用[sA,index] = sort ( A , ‘decend’ ) ;A = [ 2 , 1 , 3 , 8 ]sA = [ 8 , 3 , 2 , 1 ]index = [ 4 , 3 , 1 , 2 ] 定义函数function [输出变量] = 函数名称（输入变量）函数的中间部分都是函数体函数的最后要用end结尾输出变量和输入变量可以有多个，用逗号隔开例如： 12345function [ a , b , c ] = test ( d , e , f ) a = d + e ;b = e + f ; c = f + d ; end zeros, ones函数zeros ( 3 ) ; 1234ans = 0 0 0 0 0 0 0 0 0 zeros ( 3 , 1 ) ; 1234ans = 0 00 ones同理","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"},{"name":"Matlab","slug":"Matlab","permalink":"http://1152396492.github.io/tags/Matlab/"}]},{"title":"TOPSIS法","slug":"TOPSIS法","date":"2021-09-22T14:32:59.000Z","updated":"2021-12-25T08:27:11.162Z","comments":true,"path":"2021/09/22/TOPSIS法/","link":"","permalink":"http://1152396492.github.io/2021/09/22/TOPSIS%E6%B3%95/","excerpt":"TOPSIS法(Technique for Order Preference by Similarity to Ideal Solution)可翻译为逼近理想解排序法，也称优劣解距离法TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距","text":"TOPSIS法(Technique for Order Preference by Similarity to Ideal Solution)可翻译为逼近理想解排序法，也称优劣解距离法TOPSIS法是一种常用的综合评价方法，其能充分利用原始数据的信息，其结果能精确的反映各评价方案之间的差距 层次分析法的局限性1） 决策层不能太多，太多n会很大，潘多矩阵和一致矩阵差距大2）对于已知的指标数据，我们如何利用数据使之更加准确 一个例子对于如下表格 姓名 成绩 排名 修正后的排名 评分 小明 89 2 3 3/10=0.3 小王 60 4 1 1/10=0.1 小张 74 3 2 2/10=0.2 我 99 1 4 4/10=0.4 对于这种评价系统我们可以发现，只要保证排名不变，那么评分就不会改变 优化的想法我们可以取最高的成绩max = 99最低的成绩min = 60构造计算评分的公式: ( x - min ) / ( max - min )然后对于每一个数据进行归一化处理即可但同时最高分与最低分的评价是一定的，1&amp;0 说明为什么不直接将各自的分数除以100再进行归一化处理，这样对于数据的关联性还更强原因有三点 比较对象一般远大于两个 比较的指标往往不是一个方面的 有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的指标：GDP增速故我们最好使用上述优化的想法 拓展问题：增加指标个数 姓名 成绩 与他人争吵的次数 小明 89 2 小王 60 0 小张 74 1 清风 99 3 成绩是越大越好，这样的指标称为极大型指标（效益型指标）与他人争吵的次数越少越好，这样的指标称为极小型指标（成本型指标） 如果我们直接将这些数据加以利用显然是不合适的，因为指标类型不一样所以我们应当统一指标类型一般我们将所有的指标转化为极大型称为指标正向化（最常用） 姓名 成绩 与他人争吵的次数 正向化后的争吵次数 小明 89 2 1 小王 60 0 3 小张 74 1 2 清风 99 3 0 极小型指标转换为极大型指标的公式：max - x 标准化处理显然成绩的大小与争吵次数的大小不是一个量级上的比较为了消去不同指标量纲的影响，需要对已经正向化的矩阵进行标准化处理图像链接：我们得到了标准化处理后的指标，那么我们怎么去联系这些值呢 如何计算得分我们对于最开始的式子：( x - min ) / ( max - min )我们可以将其变形= ( x - min ) / [ ( max - x ) + ( x - min ) ]可以看作是：x与最小值的距离 / ( x与最大值的距离 + x与最小值的距离 )类比可以得出：图像链接： 上面的一大串公式可以这样理解，我们对于只有一个指标时，我们将这一列的数据找出它的最大值和最小值，对于多个指标，同理，我们先将每一列的最大值和最小值找出来。对于每一个评价对象，我们要找出它与最小值的距离可以看成一个平面直角坐标系，它的值所对应的点距离原点（最小值）的距离长度，也就是他的我们所要找的值对于最大值的寻找也同理 计算出未归一化的得分后我们将其进行归一化处理，就可得到他们的排名了 这下子再回到TOPSIS算法，我们就不难理解它为什么是优劣解距离法了吧 梳理第一步将原始矩阵正向化最常见的四种指标 指标 名称 指标特点 例子 极大型（效益型） 指标越大越好 成绩、GDP增速、企业利润 极小型（成本型） 指标越小越好 费用、坏品率、污染程度 中间型指标 越接近某个值越好 水质量评估ph值 区间型指标 落在某个区间最好 体温、水中植物性营养物量 正向化就是将所有指标类型转化为极大型指标 我们介绍了极小型转化为极大型，那么另外两种指标该如何转换呢 中间型指标{xi}是一组中间型指标序列，且最佳的数值为xbest，那么正向化的公式如下M = max { | xi - xbest | } , xi’ = 1 - | xi - xbest | / M我们可以画图去理解这个公式，也是利用距离去计算，思想大致与极小型相同 区间型指标我们设最佳区间为[a,b]M = max { a - min { xi } , max { xi } - b }xi = 1 - ( a - x ) / M , x &lt; a 1 , a &lt;= x &lt;= b 1 - ( x - b ) / M , x &gt; b思路与中间型指标也是差不多的，画图也可以理解 第二步：正向化矩阵标准化第三步：归一化处理并排名带权重的TOPSIS对于之前我们所用到的TOPSIS我们默认了指标之间的权重为1 ，然而实际情况可能更为复杂有n个要评价的对象，m个评价指标的标准化矩阵可以利用层次分析法给这m个评价指标确定权重，每个指标的权重加起来显然是为1的。我们在计算评价对象与最大值之间的距离是可以直接针对每个j（即每个指标）乘以响应的权重wj再进行开方可能有人就要问了，那你这样加起来的距离显然是要小于之前的距离呀，会对得出正确的结论有影响吗其实是没有影响的我们可以理解为对于我们建立的直角坐标系对于某个轴进行了压缩，压缩后虽然大小改变了，但是并不影响我们得出正确的结论 关于TOPSIS的代码见下一篇博客","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"}]},{"title":"c复习","slug":"c复习","date":"2021-09-19T14:32:11.000Z","updated":"2022-01-12T13:37:25.983Z","comments":true,"path":"2021/09/19/c复习/","link":"","permalink":"http://1152396492.github.io/2021/09/19/c%E5%A4%8D%E4%B9%A0/","excerpt":"这篇文章是大一刚开学对c的复习，十分的不全面，看看就行。","text":"这篇文章是大一刚开学对c的复习，十分的不全面，看看就行。 程序设计语言机器语言 汇编语言 高级语言return 0 ; return表示main函数结束，0表示程序在退出时给执行此程序的操作系统返回来一个结果，即返回值。 c程序的构成预处理部分 宏定义：#define指令定义一个宏，#undef指令删除一个宏定义 头文件包含：#include 条件编译语句：#if、#ifdef、#ifndef、#else和#endif指令根据预处理器可以测试的条件来确定是将一段文本块包含到程序还是将其排除在外说明部分 全局变量 常量：#define PI 3.1416926f \\ const float PI 3.1415926 函数声明执行部分 主函数 其他函数标识符由数字、字母和下划线字符构成的一个连续序列，不能有空白字符。区分大小写整型数据的分类基本整型（int）、短整型（short int）和长整型（long int）int 的取值范围-2147483648 与2147483647（2^31-1)、字节数4short (int)的取值范围 -32768 与 32767 之间、字节数2long (int) 主流编译器一般规定其取值范围与基本int类型相同、字节数4C语言还提供了有符号和无符号整数类型若希望表达非负整数，可以定义无符号整型，即在类型符号前面加上修饰符unsigned加上unsigned变成原来的两倍、字节数不变如：unsigned int : 0 ~ 4294967295整型常数的书写形式 十进制形式 八进制形式： 以0开头，如0100、0123、0123456 十六进制形式：以0x开头，如0x100、0x123 整型数据的储存形式：在计算机内部通常采用补码形式储存补码 （ 后面再补充相应知识 ） 浮点数类型C语言把浮点数类型分为float（单精度浮点型）、double（双精度浮点型）和long double （长双精度浮点型）如表所示 类型 字节数 有效位数 取值范围 foat 4 6 -3.4 * 10^38 ~ 3.4 * 10^38 double 8 15 -1.7 * 10^308 ~ 3.4 * 10^308 long double 16 19 -1.2 * 10^4932 ~ 3.4 * 10^4932 浮点数的书写形式 当小数点前后的数是零时，可以省略0，但是小数点不能省略如5.和.5分别表示5.0和0.5 指数形式 ： 如4.5678E2代表4.5678 * 10^2 \\ -5.7e-3代表-5.7 * 10^-3 （E和e本质是一样的） 默认情况下，浮点型常数为double型。可以在浮点型常数后面加上F(f)以表示float型；也可以在浮点型常数后面加上L(l）表示long double型 字符类型ASCII 字符集的特征：0～9、26个大写英文字母以及26哥消协的英文字母的编码各自是连续的如：A的编码加上25是Z的编码 char类型来描述单字节编码字符集中的字符类型数据C还提供了[signed] char 和 unsigned char 类型，他们的区别在于：在参加算术运算时，把字符的编码当作有符号整数还是无符号整数来看待 字符型常量的三种书写方式： 以一对单引号括起来的一个字符：’A’&#39;1’ 以字符对应的ASCII码来表示，这时必须用转义序列（以反斜杠开头的一串字符） 八进制：’\\ddd’如’101’为字母A的ASCII码的八进制表示 十六进制：’\\xhh’如’\\x41’为字母A的ASCII码的十六进制表示 特殊的转移序列符号表示 符号 含义 符号 含义 \\a 响铃 \\v 纵向制表 \\b 退格 &#39; 单引号 \\f 换页 &#39;‘ 双引号 \\n 换行 \\ |反斜杠 \\r 回车 \\0 字符串结束 \\t 横向制表 “Please enter &quot;Y&quot; or &quot;N&quot;:当字符串包含双引号”时，双引号应写成：&quot;字符常量表示单个字符，字符串常量可表示多个字符字符常量用’’表示,字符串常量用””表示在储存字符串时，通常在最后一个字符后面储存一个表示字符串结束的标记符号 两个实数相除的结果是双精度实数，两个整数相除的结果是整数 常用运算符的优先级与结合性自行百度 输入输出语句printf ( ) ; scanf ( ) ; getchar ( ) ; putchar ( ) ; puts ( ) ; gets ( ) ; 头文件/#include&lt; &gt; 表示直接去查找系统的源文件/#include” “ 表示先去找用户存放源文件的子目录再去找系统文件如果是自己写的头文件必须用第二种如果头文件不在当前目录中，可以在双引号中写出文件路径(#include “C:\\temp\\file.h” scanf 与 printf特别的，scanf ( “%2d%2d” , &amp; a , &amp; b ) ; 输入的数据可以为1234则a = 12 , b = 34 ；如果scanf ( “a=%d,b=%d\\n” , &amp; a , &amp; b ) ;则用户必须输入a=12,b=34 ;如果是scanf ( “%d * %d” , &amp; a , &amp; b ) ;那么用户输入12，34｜12#34都会得到正确的结果，因为 * 为忽略输入修饰符scanf输入时如果是%c那么空格也会被读入 空语句空语句不做任何事情其作用是用于语法上需要一条语句的地方，而该地方又不需要做任何事情；例如 123456&#123; ... goto end ; ... end : ; &#125; 12int i = 1 , sum = 0 ; for ( ; i &lt;= 100 ; sum += i , i ++ ) ; switch 语句123456switch( &lt;整式表达式&gt; ) &#123; case 常量1: 语句序列1 ; break ; case 常量2: 语句序列2 ; break ; ... default ; &#125; 常量可为1、2、3；’c’、’a’…. case 常量1: 语句序列1 ; break ;","categories":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/categories/c/"}],"tags":[{"name":"c","slug":"c","permalink":"http://1152396492.github.io/tags/c/"},{"name":"复习资料","slug":"复习资料","permalink":"http://1152396492.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"}]},{"title":"层次分析法","slug":"层次分析法","date":"2021-09-18T15:40:58.000Z","updated":"2021-12-25T08:27:38.481Z","comments":true,"path":"2021/09/18/层次分析法/","link":"","permalink":"http://1152396492.github.io/2021/09/18/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/","excerpt":"态度可以转变，生活却不可逆转。-学层次分析法有感 此文章用于记录我学习数学建模的十大模型中层次分析法的学习笔记与自己的理解，本文大多数是由清风老师的数学建模的指导归纳总结得到的，以备今后的数学建模。如果遇到了类似的题目可以尽快的找到相应的模型进行解决。如果本文能帮助到其他阅读到此文章的同志，我也是不胜荣幸。如果文章有所纰漏，也欢迎大家指出。","text":"态度可以转变，生活却不可逆转。-学层次分析法有感 此文章用于记录我学习数学建模的十大模型中层次分析法的学习笔记与自己的理解，本文大多数是由清风老师的数学建模的指导归纳总结得到的，以备今后的数学建模。如果遇到了类似的题目可以尽快的找到相应的模型进行解决。如果本文能帮助到其他阅读到此文章的同志，我也是不胜荣幸。如果文章有所纰漏，也欢迎大家指出。 用途：解决评价性问题层次分析法主要用于解决评价性问题，比如问你，选择哪种方案最好，哪个人或事物更为优秀。需要注意的是，这种问题不包括已经给出具体数据的问题，更多的是比较模糊、较为主观的问题。你需要根据自己的生活经历，网络上搜集的评价资料和结合背景材料去得到相关的评价指标。值得注意的是，我们可以在例如知网等比较权威的网站上去查找相关的论文资料并加以引用，可以让你的文章显得更为专业且结合其他人的观点可以让你的文章更为全面。 评判标准那么评价类问题怎么去评判呢，我们使用打分来解决，根据权重表格计算得分 指标与方案 指标权重 方案1 方案2 ….. 指标1 … … … … 指标2 … … … … ….. … … … … 我们不妨定义 $a_{i j}&amp; 表示为第i行第j列的元素显然针对每个因素所占的权重必定和为1，指标权重的和为1即 $a_{1-n 1}$ 之和为1对于每个指标k, $a_{k 2-n}$ 的和同样为1.而我们评判每个方案时，是不是就可以通过计算指标权重 $\\times$ 方案对应指标的值。通过比较每个方案所对应的结果，我们就可以得知最佳的方案是什么了。 重要程度表 标度 含义 1 A对于B同样重要 3 A对于B稍微重要 5 A对于B明显重要 7 A对于B强烈重要 9 A对于B极端重要 2,4,6,8 两个相邻判断的中值 其中，1/3表示B对于A稍微重要，以此类推 制作判断指标权重的表格通过以上的重要程度表，我们可以根据专家（自己）的判断，制定一份这样的表格 指标 景色 花费 居住 饮食 交通 景色 1 1/2 4 3 3 花费 2 1 7 5 5 居住 1/4 1/7 1 1/2 1/3 饮食 1/3 1/5 2 1 1 交通 1/3 1/5 3 1 1 $a_{i j}$ 表示与j指标相比，i的重要程度$a_{i j}$ &gt;0且 $a_{i j}$ * $a_{j i}$ = 1 称之为正互反矩阵。此矩阵为判断矩阵 一致矩阵由于 $a_{i j}$ = i的重要程度/j的重要程度我们可以知道 $a_{i j}$ * $a_{j k}$ = $a_{i k}$ ，列出数学计算公式即可得到而满足上述关系的矩阵我们称之为一致矩阵一致矩阵有一个特点，各行或者各列之间成倍数关系，利用这个我们可以直接得出这个矩阵是不是一致矩阵 最大特征值由于本人大一，太菜，没有学过线性代数，我只能复制清风老师上课给的一个性质。这个最大特征值你可以不用了解它究竟是个啥，怎么去计算，matlab上面有它的计算函数我们目前只需要知道对于特征值λ：n阶正互反矩阵A为一致矩阵时当且仅当最大特征值λmax=n否则λmax必定大于n 一致性检验步骤： 计算一致性指标CI = （ λmax - n ) / ( n - 1 ) 查找对应的平均随机一致性指标RI 阶数 RI 1 0 2 0 3 0.52 4 0.89 5 1.12 6 1.26 7 1.36 8 1.41 9 1.46 10 1.49 11 1.52 12 1.54 13 1.56 14 1.58 15 1.59 计算一致性比例CR=CI/RI如果CR&lt;0.1则一致性检验可以接受，否则需要修正什么，你问我怎么去修正？你是专家，肯定你来修正啊。计算一致矩阵的权重直接对第一列进行归一化处理，因为第一列与其他列都是成比例的，直接对第一列进行归一化处理是等于其他列对归一化处理：比如说对于如下矩阵 PD|A|BA|1|2B|1/2|1 我们直接计算A：1/（1+1/2） B：（1/2）/（1+1/2）即可 计算判断矩阵的权重我们不妨先假设矩阵A=a11 a12 …. a1na21 a22 …. a2n… … …. …an1 an2 …. ann 算术平均法求权重 分别对每一列进行归一化处理 把每一行的数据分别加起来 把2得到的数据除以n这种方法称之为算术平均法求权重那么算术平均法求得得权重向量wi","categories":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"层次分析法","slug":"层次分析法","permalink":"http://1152396492.github.io/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"}]}],"categories":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/categories/%E6%9D%82/"},{"name":"c","slug":"c","permalink":"http://1152396492.github.io/categories/c/"},{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"论文","slug":"论文","permalink":"http://1152396492.github.io/categories/%E8%AE%BA%E6%96%87/"},{"name":"杂谈","slug":"杂谈","permalink":"http://1152396492.github.io/categories/%E6%9D%82%E8%B0%88/"},{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"}],"tags":[{"name":"杂","slug":"杂","permalink":"http://1152396492.github.io/tags/%E6%9D%82/"},{"name":"c","slug":"c","permalink":"http://1152396492.github.io/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://1152396492.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"题解","slug":"题解","permalink":"http://1152396492.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"比赛","slug":"比赛","permalink":"http://1152396492.github.io/tags/%E6%AF%94%E8%B5%9B/"},{"name":"DP","slug":"DP","permalink":"http://1152396492.github.io/tags/DP/"},{"name":"算法","slug":"算法","permalink":"http://1152396492.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Tarjan","slug":"Tarjan","permalink":"http://1152396492.github.io/tags/Tarjan/"},{"name":"LCA","slug":"LCA","permalink":"http://1152396492.github.io/tags/LCA/"},{"name":"动漫","slug":"动漫","permalink":"http://1152396492.github.io/tags/%E5%8A%A8%E6%BC%AB/"},{"name":"线段树","slug":"线段树","permalink":"http://1152396492.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://1152396492.github.io/tags/Dijkstra/"},{"name":"索引","slug":"索引","permalink":"http://1152396492.github.io/tags/%E7%B4%A2%E5%BC%95/"},{"name":"诗","slug":"诗","permalink":"http://1152396492.github.io/tags/%E8%AF%97/"},{"name":"结构","slug":"结构","permalink":"http://1152396492.github.io/tags/%E7%BB%93%E6%9E%84/"},{"name":"指针","slug":"指针","permalink":"http://1152396492.github.io/tags/%E6%8C%87%E9%92%88/"},{"name":"c语言","slug":"c语言","permalink":"http://1152396492.github.io/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"论文","slug":"论文","permalink":"http://1152396492.github.io/tags/%E8%AE%BA%E6%96%87/"},{"name":"云计算","slug":"云计算","permalink":"http://1152396492.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"书评","slug":"书评","permalink":"http://1152396492.github.io/tags/%E4%B9%A6%E8%AF%84/"},{"name":"生活","slug":"生活","permalink":"http://1152396492.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"娱乐","slug":"娱乐","permalink":"http://1152396492.github.io/tags/%E5%A8%B1%E4%B9%90/"},{"name":"数学建模","slug":"数学建模","permalink":"http://1152396492.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"},{"name":"插值算法","slug":"插值算法","permalink":"http://1152396492.github.io/tags/%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/"},{"name":"TOPSIS","slug":"TOPSIS","permalink":"http://1152396492.github.io/tags/TOPSIS/"},{"name":"Matlab","slug":"Matlab","permalink":"http://1152396492.github.io/tags/Matlab/"},{"name":"复习资料","slug":"复习资料","permalink":"http://1152396492.github.io/tags/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/"},{"name":"层次分析法","slug":"层次分析法","permalink":"http://1152396492.github.io/tags/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"}]}